<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Big Technology Video Tracker</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%234a6fa5'/%3E%3Crect x='15' y='40' width='12' height='30' rx='2' fill='%23e0e0e0'/%3E%3Crect x='30' y='30' width='12' height='40' rx='2' fill='%23f0f0f0'/%3E%3Crect x='45' y='20' width='12' height='50' rx='2' fill='%23e0e0e0'/%3E%3Crect x='60' y='35' width='12' height='35' rx='2' fill='%23f0f0f0'/%3E%3Crect x='75' y='25' width='12' height='45' rx='2' fill='%23e0e0e0'/%3E%3Ccircle cx='50' cy='50' r='42' fill='none' stroke='%23c9953c' stroke-width='2.5' stroke-dasharray='6 4' opacity='.6'/%3E%3Ccircle cx='22' cy='18' r='3' fill='%23c9953c'/%3E%3Ccircle cx='78' cy='15' r='2.5' fill='%23e0b05e'/%3E%3Ccircle cx='85' cy='55' r='2' fill='%23c9953c'/%3E%3C/svg%3E" type="image/svg+xml">
    <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --navy: #1a2332;
            --navy-light: #243044;
            --navy-mid: #2c3e56;
            --slate: #3d5068;
            --steel: #8899aa;
            --silver: #b8c5d1;
            --cloud: #e8ecf1;
            --white: #f7f8fa;
            --pure-white: #ffffff;
            --accent: #c9953c;
            --accent-light: #e0b05e;
            --accent-dim: #a07a2e;
            --blue: #4a90d9;
            --blue-hover: #3a7bc8;
            --red: #c0392b;
            --red-hover: #a5311f;
            --green: #27ae60;
            --green-light: #2ecc71;
            --radius: 8px;
            --shadow: 0 2px 12px rgba(0,0,0,0.08);
            --shadow-lg: 0 8px 32px rgba(0,0,0,0.12);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--white); color: var(--navy); -webkit-font-smoothing: antialiased; }

        /* ---- Header ---- */
        .header {
            background: linear-gradient(135deg, var(--navy) 0%, var(--navy-light) 100%);
            color: var(--pure-white);
            padding: 20px 32px;
            display: flex;
            align-items: center;
            gap: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        .header-logo {
            width: 48px; height: 48px; border-radius: 12px; object-fit: cover;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .header-text h1 { font-size: 22px; font-weight: 700; letter-spacing: -0.3px; }
        .header-text .subtitle {
            font-size: 12px; font-weight: 400; color: var(--silver);
            letter-spacing: 1px; text-transform: uppercase; margin-top: 2px;
        }

        /* ---- Month Switcher ---- */
        .month-bar {
            background: var(--navy-light);
            padding: 8px 32px;
            display: flex;
            align-items: center;
            gap: 6px;
            overflow-x: auto;
        }
        .month-pill {
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            color: var(--silver);
            background: transparent;
            border: 1px solid transparent;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s ease;
            font-family: 'Inter', sans-serif;
        }
        .month-pill:hover { color: var(--pure-white); background: rgba(255,255,255,0.08); }
        .month-pill.active { color: var(--pure-white); background: var(--accent); border-color: var(--accent); }
        .month-pill.add-month {
            color: var(--accent-light);
            border: 1px dashed var(--accent-light);
            opacity: 0.7;
        }
        .month-pill.add-month:hover { opacity: 1; background: rgba(201,149,60,0.1); }
        .month-delete {
            margin-left: 6px; font-size: 13px; opacity: 0.5; cursor: pointer;
        }
        .month-delete:hover { opacity: 1; color: var(--red); }

        /* ---- Tabs ---- */
        .tabs {
            display: flex; background: var(--pure-white);
            border-bottom: 1px solid var(--cloud); padding: 0 32px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.04);
        }
        .tab {
            padding: 14px 28px; cursor: pointer; font-size: 13px; font-weight: 600;
            color: var(--steel); border-bottom: 2px solid transparent;
            transition: all 0.25s ease; letter-spacing: 0.3px; text-transform: uppercase;
        }
        .tab:hover { color: var(--navy); }
        .tab.active { color: var(--navy); border-bottom-color: var(--accent); }

        /* ---- Stats Bar ---- */
        .stats-bar {
            display: flex; gap: 16px; margin-bottom: 20px; flex-wrap: wrap;
        }
        .stat-card {
            display: flex; align-items: center; gap: 12px;
            background: var(--pure-white); border: 1px solid var(--cloud);
            border-radius: var(--radius); padding: 14px 20px; min-width: 150px;
            box-shadow: var(--shadow);
        }
        .stat-icon {
            width: 40px; height: 40px; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; font-weight: 700;
        }
        .stat-icon.longform { background: #e8f0fe; color: #2a6bc5; }
        .stat-icon.clip { background: #fef5e7; color: #c27a0e; }
        .stat-icon.short { background: #e8f8ef; color: #1a8a4a; }
        .stat-icon.total { background: var(--cloud); color: var(--navy); }
        .stat-icon.thumb { background: #f3e8ff; color: #7c3aed; }
        .stat-info .stat-count { font-size: 24px; font-weight: 700; color: var(--navy); line-height: 1; }
        .stat-info .stat-label { font-size: 11px; font-weight: 600; color: var(--steel); text-transform: uppercase; letter-spacing: 0.5px; margin-top: 2px; }

        /* ---- Content ---- */
        .content { padding: 28px 32px; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* ---- Toolbar ---- */
        .toolbar { display: flex; gap: 10px; margin-bottom: 20px; align-items: center; }
        .btn {
            padding: 9px 18px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 12px; font-weight: 600; font-family: 'Inter', sans-serif;
            letter-spacing: 0.3px; text-transform: uppercase;
            transition: all 0.2s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }
        .btn:active { transform: translateY(1px); }
        .btn-primary { background: var(--navy); color: var(--pure-white); }
        .btn-primary:hover { background: var(--navy-light); box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
        .btn-danger { background: var(--red); color: var(--pure-white); }
        .btn-danger:hover { background: var(--red-hover); }
        .btn-secondary { background: var(--cloud); color: var(--navy); }
        .btn-secondary:hover { background: var(--silver); }
        .btn-email { background: var(--blue); color: var(--pure-white); }
        .btn-email:hover { background: var(--blue-hover); }
        .btn-accent { background: var(--accent); color: var(--pure-white); }
        .btn-accent:hover { background: var(--accent-dim); }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }

        /* ---- Table ---- */
        .table-wrap {
            overflow-x: auto; background: var(--pure-white);
            border-radius: var(--radius); box-shadow: var(--shadow);
            border: 1px solid var(--cloud);
        }
        table { width: 100%; border-collapse: collapse; font-size: 13px; min-width: 1500px; table-layout: fixed; }
        thead { background: var(--navy); }
        th {
            padding: 12px 14px; text-align: left; font-weight: 600; font-size: 11px;
            letter-spacing: 0.6px; text-transform: uppercase; color: var(--silver);
            white-space: nowrap; position: sticky; top: 0; z-index: 10;
            overflow: hidden;
        }
        /* Column resize handles */
        .col-resize-handle {
            position: absolute; right: 0; top: 0; bottom: 0; width: 5px;
            cursor: col-resize; z-index: 11;
        }
        .col-resize-handle:hover, .col-resize-handle.active {
            background: var(--accent);
        }
        body.col-resizing { cursor: col-resize !important; user-select: none; }
        body.col-resizing * { cursor: col-resize !important; }
        td { padding: 10px 14px; border-bottom: 1px solid var(--cloud); vertical-align: middle; overflow: hidden; }
        tr { transition: background 0.15s ease; }
        tr:hover { background: #f0f3f7; }
        tr:nth-child(even) { background: #fafbfc; }
        tr:nth-child(even):hover { background: #f0f3f7; }

        td input[type="text"], td select {
            width: 100%; border: 1px solid transparent; background: transparent;
            padding: 5px 8px; font-size: 13px; font-family: 'Inter', sans-serif;
            border-radius: 5px; transition: all 0.2s ease; color: var(--navy);
        }
        td input[type="text"]::placeholder { color: var(--silver); }
        td input[type="text"]:hover, td select:hover { border-color: var(--cloud); background: var(--white); }
        td input[type="text"]:focus, td select:focus { border-color: var(--accent); outline: none; background: var(--pure-white); box-shadow: 0 0 0 3px rgba(201,149,60,0.1); }
        td select { cursor: pointer; }
        td input[type="checkbox"] { width: 16px; height: 16px; cursor: pointer; accent-color: var(--accent); }
        th.col-checkbox, td.col-checkbox { width: 44px; text-align: center; }
        th.col-email, td.col-email { width: 52px; text-align: center; }
        .check-col select { width: 68px; }

        /* ---- Color-coded selects ---- */
        select.select-short { background: #e8f8ef; color: #1a8a4a; font-weight: 600; border: 1px solid #b8e6cc; }
        select.select-clip { background: #fef5e7; color: #c27a0e; font-weight: 600; border: 1px solid #f5ddb0; }
        select.select-longform { background: #e8f0fe; color: #2a6bc5; font-weight: 600; border: 1px solid #b8d0f5; }
        select.select-yes { background: #e8f8ef; color: #1a8a4a; font-weight: 600; border: 1px solid #b8e6cc; }
        select.select-no { background: #fde8e6; color: #c0392b; font-weight: 600; border: 1px solid #f5b8b3; }
        select.select-empty { background: transparent; color: var(--steel); font-weight: 400; border: 1px solid transparent; }

        /* ---- Settings Tab ---- */
        .settings-card {
            background: var(--pure-white); border-radius: var(--radius);
            box-shadow: var(--shadow); border: 1px solid var(--cloud);
            padding: 32px; max-width: 640px;
        }
        .settings-card h2 { font-size: 17px; font-weight: 700; margin-bottom: 6px; color: var(--navy); letter-spacing: -0.2px; }
        .settings-card p { font-size: 13px; color: var(--steel); margin-bottom: 20px; line-height: 1.5; }
        .settings-section { margin-bottom: 28px; padding-bottom: 28px; border-bottom: 1px solid var(--cloud); }
        .settings-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }

        .email-list { display: flex; flex-direction: column; gap: 8px; margin-bottom: 16px; }
        .email-row { display: flex; gap: 8px; align-items: center; }
        .email-row input {
            flex: 1; padding: 9px 14px; border: 1px solid var(--cloud); border-radius: 6px;
            font-size: 14px; font-family: 'Inter', sans-serif; color: var(--navy); transition: all 0.2s ease;
        }
        .email-row input:focus { border-color: var(--accent); outline: none; box-shadow: 0 0 0 3px rgba(201,149,60,0.1); }
        .remove-email {
            background: none; border: none; color: var(--red); cursor: pointer;
            font-size: 18px; padding: 4px 8px; border-radius: 4px; transition: background 0.15s;
        }
        .remove-email:hover { background: #fde8e6; }


        .status-badge { display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 11px; font-weight: 600; letter-spacing: 0.3px; }
        .status-ok { background: #e8f8ef; color: var(--green); }
        .status-err { background: #fde8e6; color: var(--red); }
        .status-warn { background: #fef5e7; color: var(--accent-dim); }

        /* ---- New Month Form ---- */
        .new-month-card {
            background: var(--pure-white); border-radius: var(--radius);
            box-shadow: var(--shadow); border: 1px solid var(--cloud);
            padding: 32px; max-width: 480px;
        }
        .new-month-card h2 { font-size: 17px; font-weight: 700; margin-bottom: 6px; color: var(--navy); }
        .new-month-card p { font-size: 13px; color: var(--steel); margin-bottom: 20px; line-height: 1.5; }
        .month-select-row { display: flex; gap: 12px; margin-bottom: 20px; }
        .month-select-row select, .month-select-row input {
            padding: 9px 14px; border: 1px solid var(--cloud); border-radius: 6px;
            font-size: 14px; font-family: 'Inter', sans-serif; color: var(--navy); flex: 1;
        }
        .month-select-row select:focus, .month-select-row input:focus { border-color: var(--accent); outline: none; }

        /* ---- Spinner ---- */
        .sending { position: relative; pointer-events: none; }
        .sending::after {
            content: ''; position: absolute; top: 50%; left: 50%; width: 16px; height: 16px;
            margin: -8px 0 0 -8px; border: 2px solid var(--accent); border-top-color: transparent;
            border-radius: 50%; animation: spin 0.6s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* ---- Dashboard ---- */
        .dash-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .dash-card {
            background: var(--pure-white);
            border: 1px solid var(--cloud);
            border-radius: var(--radius);
            padding: 24px;
            box-shadow: var(--shadow);
        }
        .dash-card-header {
            display: flex; align-items: center; gap: 10px; margin-bottom: 20px;
            padding-bottom: 14px; border-bottom: 1px solid var(--cloud);
        }
        .dash-card-header h3 { font-size: 16px; font-weight: 700; color: var(--navy); }
        .dash-card-icon {
            width: 36px; height: 36px; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px;
        }
        .dash-yt .dash-card-icon { background: #fee2e2; color: #dc2626; }
        .dash-alltime .dash-card-icon { background: #e8f0fe; color: #2a6bc5; }
        .dash-monthly-breakdown .dash-card-icon { background: #fef5e7; color: #c27a0e; }
        .dash-monthly-breakdown { grid-column: 1 / -1; }
        .dash-yt-stats { display: flex; flex-direction: column; gap: 16px; }
        .dash-big-stat { text-align: center; padding: 12px 0; }
        .dash-big-number { font-size: 42px; font-weight: 700; color: var(--navy); line-height: 1; }
        .dash-big-label { font-size: 12px; font-weight: 600; color: var(--steel); text-transform: uppercase; letter-spacing: 0.5px; margin-top: 6px; }
        .dash-yt-row { display: flex; gap: 16px; }
        .dash-mini-stat {
            flex: 1; text-align: center; padding: 14px;
            background: var(--white); border-radius: 8px; border: 1px solid var(--cloud);
        }
        .dash-mini-number { font-size: 22px; font-weight: 700; color: var(--navy); }
        .dash-mini-label { font-size: 11px; font-weight: 600; color: var(--steel); text-transform: uppercase; letter-spacing: 0.3px; margin-top: 4px; }
        .dash-yt-trajectory {
            margin-top: 16px; padding: 16px; text-align: center;
            background: linear-gradient(135deg, #fef5e7 0%, #fff8ee 100%);
            border: 1px solid rgba(226,166,49,0.25); border-radius: 8px;
        }
        .dash-traj-label { font-size: 11px; font-weight: 600; color: var(--accent-dim); text-transform: uppercase; letter-spacing: 0.5px; }
        .dash-traj-date { font-size: 22px; font-weight: 700; color: var(--navy); margin-top: 4px; }
        .dash-traj-sub { font-size: 11px; color: var(--steel); margin-top: 4px; }
        .dash-yt-updated { font-size: 11px; color: var(--steel); margin-top: 14px; text-align: center; }
        .dash-alltime-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .dash-alltime-item {
            text-align: center; padding: 16px;
            background: var(--white); border-radius: 8px; border: 1px solid var(--cloud);
        }
        .dash-alltime-num { font-size: 28px; font-weight: 700; color: var(--navy); }
        .dash-alltime-lbl { font-size: 11px; font-weight: 600; color: var(--steel); text-transform: uppercase; letter-spacing: 0.3px; margin-top: 4px; }
        .dash-months-table { width: 100%; }
        .dash-months-table table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .dash-months-table th {
            text-align: left; font-weight: 600; font-size: 11px; text-transform: uppercase;
            letter-spacing: 0.5px; color: var(--steel); padding: 10px 12px;
            border-bottom: 2px solid var(--cloud);
        }
        .dash-months-table td { padding: 10px 12px; border-bottom: 1px solid var(--cloud); color: var(--navy); }
        .dash-months-table tr:last-child td { border-bottom: none; font-weight: 700; background: var(--white); }
        @media (max-width: 768px) {
            .dash-grid { grid-template-columns: 1fr; }
            .dash-monthly-breakdown { grid-column: 1; }
        }

        /* ---- Video Performance ---- */
        .vp-header {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 20px; flex-wrap: wrap; gap: 12px;
        }
        .vp-header h2 { font-size: 18px; font-weight: 700; color: var(--navy); }
        .vp-meta { font-size: 12px; color: var(--steel); }
        .vp-legend {
            display: flex; gap: 16px; align-items: center;
            padding: 12px 20px; background: var(--pure-white); border: 1px solid var(--cloud);
            border-radius: var(--radius); margin-bottom: 16px; box-shadow: var(--shadow);
        }
        .vp-legend-item { display: flex; align-items: center; gap: 6px; font-size: 12px; font-weight: 600; color: var(--navy); }
        .vp-legend-dot { width: 12px; height: 12px; border-radius: 3px; }
        .vp-legend-dot.green { background: #22c55e; }
        .vp-legend-dot.yellow { background: #eab308; }
        .vp-legend-dot.red { background: #ef4444; }
        .vp-avg-bar {
            padding: 10px 20px; background: linear-gradient(135deg, #f0f3f7, #e8ecf1);
            border-radius: var(--radius); margin-bottom: 16px; font-size: 13px;
            font-weight: 600; color: var(--navy); text-align: center;
        }
        .vp-list {
            display: flex; flex-direction: column; gap: 8px;
        }
        .vp-item {
            display: flex; align-items: center; gap: 14px;
            background: var(--pure-white); border: 1px solid var(--cloud);
            border-radius: var(--radius); padding: 12px 16px;
            box-shadow: var(--shadow); border-left: 4px solid var(--cloud);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        .vp-item:hover { transform: translateY(-1px); box-shadow: var(--shadow-lg); }
        .vp-item.green { border-left-color: #22c55e; }
        .vp-item.yellow { border-left-color: #eab308; }
        .vp-item.red { border-left-color: #ef4444; }
        .vp-thumb {
            width: 120px; height: 68px; border-radius: 6px; object-fit: cover;
            flex-shrink: 0; background: var(--cloud);
        }
        .vp-info { flex: 1; min-width: 0; }
        .vp-title {
            font-size: 14px; font-weight: 600; color: var(--navy);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .vp-date { font-size: 11px; color: var(--steel); margin-top: 2px; }
        .vp-duration { font-size: 11px; color: var(--steel); }
        .vp-views {
            font-size: 14px; font-weight: 700; padding: 6px 14px;
            border-radius: 20px; white-space: nowrap; flex-shrink: 0;
        }
        .vp-views.green { background: #dcfce7; color: #15803d; }
        .vp-views.yellow { background: #fef9c3; color: #a16207; }
        .vp-views.red { background: #fee2e2; color: #b91c1c; }
        .vp-loading {
            text-align: center; padding: 60px 20px; color: var(--steel);
            font-size: 14px; font-weight: 500;
        }
        .vp-loading .spinner {
            width: 32px; height: 32px; border: 3px solid var(--cloud);
            border-top-color: var(--accent); border-radius: 50%;
            animation: spin 0.8s linear infinite; margin: 0 auto 16px;
        }
        .vp-insights {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border-radius: var(--radius); padding: 20px 24px; margin-bottom: 16px;
            box-shadow: var(--shadow);
        }
        .vp-insights-title {
            font-size: 12px; font-weight: 700; text-transform: uppercase;
            letter-spacing: 0.8px; color: var(--accent-light); margin-bottom: 12px;
        }
        .vp-insights ul { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 8px; }
        .vp-insights li {
            font-size: 13px; color: #e2e8f0; line-height: 1.5;
            padding-left: 20px; position: relative;
        }
        .vp-insights li::before {
            content: '‚Üí'; position: absolute; left: 0; color: var(--accent-light); font-weight: 700;
        }
        .vp-pagination {
            display: flex; align-items: center; justify-content: center;
            gap: 16px; margin-top: 20px; padding: 12px 0;
        }
        .vp-page-btn {
            width: 40px; height: 40px; border-radius: 50%; border: 1px solid var(--cloud);
            background: var(--pure-white); color: var(--navy); font-size: 18px; font-weight: 700;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s ease; box-shadow: var(--shadow); font-family: 'Inter', sans-serif;
        }
        .vp-page-btn:hover:not(:disabled) { background: var(--navy); color: var(--pure-white); }
        .vp-page-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .vp-page-info { font-size: 13px; font-weight: 600; color: var(--steel); }
        @media (max-width: 640px) {
            .vp-item { flex-wrap: wrap; }
            .vp-thumb { width: 100%; height: auto; aspect-ratio: 16/9; }
        }

        /* ---- News Briefs ---- */
        .nb-header {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 20px; flex-wrap: wrap; gap: 12px;
        }
        .nb-header h2 { font-size: 18px; font-weight: 700; color: var(--navy); }
        .nb-week-nav {
            display: flex; align-items: center; gap: 12px;
        }
        .nb-week-label {
            font-size: 13px; font-weight: 600; color: var(--steel);
            min-width: 200px; text-align: center;
        }
        .nb-week-btn {
            width: 36px; height: 36px; border-radius: 50%; border: 1px solid var(--cloud);
            background: var(--pure-white); color: var(--navy); font-size: 16px; font-weight: 700;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s ease; box-shadow: var(--shadow); font-family: 'Inter', sans-serif;
        }
        .nb-week-btn:hover:not(:disabled) { background: var(--navy); color: var(--pure-white); }
        .nb-week-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .nb-actions {
            display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; align-items: center;
        }
        .nb-actions .btn { font-size: 12px; }
        .nb-status {
            font-size: 12px; color: var(--steel); margin-left: auto;
        }
        .nb-status.success { color: var(--green); }
        .nb-list {
            display: flex; flex-direction: column; gap: 0;
            background: var(--pure-white); border: 1px solid var(--cloud);
            border-radius: var(--radius); box-shadow: var(--shadow); overflow: hidden;
        }
        .nb-item {
            display: flex; align-items: flex-start; gap: 14px;
            padding: 16px 20px;
            border-bottom: 1px solid var(--cloud);
            transition: background 0.15s ease;
        }
        .nb-item:last-child { border-bottom: none; }
        .nb-item:hover { background: #f0f3f7; }
        .nb-rank {
            font-size: 14px; font-weight: 700; color: var(--accent);
            min-width: 28px; text-align: center; padding-top: 1px;
        }
        .nb-content { flex: 1; min-width: 0; }
        .nb-headline {
            font-size: 14px; font-weight: 600; color: var(--navy);
            line-height: 1.4; margin-bottom: 4px;
        }
        .nb-source {
            font-size: 12px; font-weight: 600; color: var(--steel);
        }
        .nb-source a {
            color: var(--blue); text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s ease;
        }
        .nb-source a:hover { border-bottom-color: var(--blue); }
        .nb-add-link {
            display: flex; gap: 10px; margin-bottom: 16px;
            padding: 14px 16px; background: var(--pure-white); border: 2px dashed var(--cloud);
            border-radius: var(--radius); align-items: center; transition: border-color 0.2s;
        }
        .nb-add-link:focus-within { border-color: var(--accent); }
        .nb-add-link input {
            flex: 1; border: none; outline: none; font-size: 14px; font-family: 'Inter', sans-serif;
            color: var(--navy); background: transparent;
        }
        .nb-add-link input::placeholder { color: var(--silver); }
        .nb-add-link .btn { flex-shrink: 0; }
        .nb-added-tag {
            display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 10px;
            font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;
            background: #dbeafe; color: #1d4ed8; margin-left: 8px;
        }
        .nb-date {
            font-size: 11px; color: var(--silver); margin-left: 8px; font-weight: 400;
        }
        .nb-empty {
            text-align: center; padding: 60px 20px; color: var(--steel);
            font-size: 14px; font-weight: 500;
        }
        .nb-email-row {
            display: flex; align-items: center; gap: 12px; margin-top: 20px;
            padding: 16px 20px; background: var(--pure-white); border: 1px solid var(--cloud);
            border-radius: var(--radius); box-shadow: var(--shadow);
        }
        .nb-email-row label { font-size: 13px; font-weight: 600; color: var(--navy); }
        .nb-email-status {
            font-size: 12px; color: var(--steel); margin-left: auto;
        }
        .nb-toggle {
            position: relative; width: 44px; height: 24px; cursor: pointer;
        }
        .nb-toggle input { opacity: 0; width: 0; height: 0; }
        .nb-toggle-slider {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: var(--cloud); border-radius: 12px; transition: 0.3s;
        }
        .nb-toggle-slider::before {
            content: ''; position: absolute; width: 18px; height: 18px;
            left: 3px; bottom: 3px; background: var(--pure-white);
            border-radius: 50%; transition: 0.3s; box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }
        .nb-toggle input:checked + .nb-toggle-slider { background: var(--accent); }
        .nb-toggle input:checked + .nb-toggle-slider::before { transform: translateX(20px); }

        /* ---- Thumbnail Performance ---- */
        .tp-header {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 20px; flex-wrap: wrap; gap: 12px;
        }
        .tp-header h2 { font-size: 18px; font-weight: 700; color: var(--navy); }
        .tp-meta { font-size: 12px; color: var(--steel); }
        .tp-tier {
            margin-bottom: 28px;
        }
        .tp-tier-header {
            display: flex; align-items: center; gap: 10px;
            margin-bottom: 14px; padding-bottom: 8px; border-bottom: 2px solid var(--cloud);
        }
        .tp-tier-badge {
            padding: 4px 12px; border-radius: 20px; font-size: 11px;
            font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;
        }
        .tp-tier-badge.top { background: #dcfce7; color: #15803d; }
        .tp-tier-badge.mid { background: #fef9c3; color: #a16207; }
        .tp-tier-badge.bottom { background: #fee2e2; color: #b91c1c; }
        .tp-tier-label {
            font-size: 14px; font-weight: 600; color: var(--navy);
        }
        .tp-tier-range {
            font-size: 12px; color: var(--steel); margin-left: auto;
        }
        .tp-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
        }
        .tp-card {
            background: var(--pure-white); border: 1px solid var(--cloud);
            border-radius: var(--radius); overflow: hidden;
            box-shadow: var(--shadow); transition: transform 0.15s ease, box-shadow 0.15s ease;
            position: relative;
        }
        .tp-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-lg); }
        .tp-card.top { border-top: 3px solid #22c55e; }
        .tp-card.mid { border-top: 3px solid #eab308; }
        .tp-card.bottom { border-top: 3px solid #ef4444; }
        .tp-card-img {
            width: 100%; aspect-ratio: 16/9; object-fit: cover;
            display: block; background: var(--cloud);
        }
        .tp-card-body {
            padding: 12px 14px;
        }
        .tp-card-title {
            font-size: 13px; font-weight: 600; color: var(--navy);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            margin-bottom: 6px;
        }
        .tp-card-stats {
            display: flex; align-items: center; justify-content: space-between;
            gap: 8px;
        }
        .tp-card-views {
            font-size: 14px; font-weight: 700;
        }
        .tp-card-views.top { color: #15803d; }
        .tp-card-views.mid { color: #a16207; }
        .tp-card-views.bottom { color: #b91c1c; }
        .tp-card-date {
            font-size: 11px; color: var(--steel);
        }
        .tp-rank {
            position: absolute; top: 8px; left: 8px;
            background: rgba(26, 35, 50, 0.85); color: var(--pure-white);
            font-size: 11px; font-weight: 700; padding: 3px 8px;
            border-radius: 4px; backdrop-filter: blur(4px);
        }
        @media (max-width: 640px) {
            .tp-grid { grid-template-columns: 1fr; }
        }

        /* ---- Sub Growth ---- */
        .sg-header {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 20px; flex-wrap: wrap; gap: 12px;
        }
        .sg-header h2 { font-size: 18px; font-weight: 700; color: var(--navy); }
        .sg-meta { font-size: 12px; color: var(--steel); }
        .sg-controls { display: flex; align-items: center; gap: 10px; }
        .sg-controls select {
            font-family: 'Inter', sans-serif; font-size: 12px; font-weight: 500;
            padding: 6px 12px; border-radius: 6px; border: 1px solid var(--cloud);
            background: var(--pure-white); color: var(--navy); cursor: pointer;
        }
        .sg-stats {
            display: flex; gap: 16px; margin-bottom: 24px; flex-wrap: wrap;
        }
        .sg-stat {
            flex: 1; min-width: 140px; text-align: center; padding: 18px 14px;
            background: var(--pure-white); border: 1px solid var(--cloud);
            border-radius: var(--radius); box-shadow: var(--shadow);
        }
        .sg-stat-num { font-size: 28px; font-weight: 700; color: var(--navy); line-height: 1; }
        .sg-stat-num.positive { color: var(--green); }
        .sg-stat-num.negative { color: var(--red); }
        .sg-stat-label {
            font-size: 11px; font-weight: 600; color: var(--steel);
            text-transform: uppercase; letter-spacing: 0.4px; margin-top: 6px;
        }
        .sg-chart-wrap {
            background: var(--pure-white); border: 1px solid var(--cloud);
            border-radius: var(--radius); box-shadow: var(--shadow);
            padding: 24px; margin-bottom: 24px;
        }
        .sg-chart-title {
            font-size: 14px; font-weight: 700; color: var(--navy); margin-bottom: 16px;
        }
        .sg-chart { width: 100%; overflow-x: auto; }
        .sg-chart svg { display: block; }
        .sg-chart svg text { font-family: 'Inter', sans-serif; }
        .sg-table-wrap {
            background: var(--pure-white); border: 1px solid var(--cloud);
            border-radius: var(--radius); box-shadow: var(--shadow);
            overflow: hidden;
        }
        .sg-table-title {
            font-size: 14px; font-weight: 700; color: var(--navy);
            padding: 16px 20px; border-bottom: 1px solid var(--cloud);
        }
        .sg-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .sg-table thead { background: var(--navy); }
        .sg-table th {
            padding: 10px 14px; text-align: left; font-weight: 600; font-size: 11px;
            letter-spacing: 0.5px; text-transform: uppercase; color: var(--silver);
        }
        .sg-table td { padding: 9px 14px; border-bottom: 1px solid var(--cloud); color: var(--navy); }
        .sg-table tr:hover { background: #f0f3f7; }
        .sg-table tr:nth-child(even) { background: #fafbfc; }
        .sg-table tr:nth-child(even):hover { background: #f0f3f7; }
        .sg-net-pos { color: var(--green); font-weight: 600; }
        .sg-net-neg { color: var(--red); font-weight: 600; }
        .sg-bar {
            display: inline-block; height: 14px; border-radius: 3px; vertical-align: middle;
            min-width: 2px; transition: width 0.3s ease;
        }
        .sg-bar.gained { background: #22c55e; }
        .sg-bar.lost { background: #ef4444; }

        /* ---- Podcast Analytics ---- */
        .pod-header {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 20px; flex-wrap: wrap; gap: 12px;
        }
        .pod-header h2 { font-size: 18px; font-weight: 700; color: var(--navy); }
        .pod-meta { font-size: 12px; color: var(--steel); }
        .pod-stats {
            display: flex; gap: 16px; margin-bottom: 24px; flex-wrap: wrap;
        }
        .pod-stat {
            flex: 1; min-width: 130px; text-align: center; padding: 18px 14px;
            background: var(--pure-white); border: 1px solid var(--cloud);
            border-radius: var(--radius); box-shadow: var(--shadow);
        }
        .pod-stat-num { font-size: 28px; font-weight: 700; color: var(--navy); line-height: 1; }
        .pod-stat-label {
            font-size: 11px; font-weight: 600; color: var(--steel);
            text-transform: uppercase; letter-spacing: 0.4px; margin-top: 6px;
        }
        .pod-chart-wrap {
            background: var(--pure-white); border: 1px solid var(--cloud);
            border-radius: var(--radius); box-shadow: var(--shadow);
            padding: 24px; margin-bottom: 24px;
        }
        .pod-chart-title {
            font-size: 14px; font-weight: 700; color: var(--navy); margin-bottom: 16px;
        }
        .pod-chart { width: 100%; overflow-x: auto; }
        .pod-chart svg { display: block; }
        .pod-chart svg text { font-family: 'Inter', sans-serif; }
        .pod-top-list {
            background: var(--pure-white); border: 1px solid var(--cloud);
            border-radius: var(--radius); box-shadow: var(--shadow);
            overflow: hidden; margin-bottom: 24px;
        }
        .pod-top-title {
            font-size: 14px; font-weight: 700; color: var(--navy);
            padding: 16px 20px; border-bottom: 1px solid var(--cloud);
        }
        .pod-ep {
            display: flex; align-items: center; gap: 14px;
            padding: 12px 20px; border-bottom: 1px solid var(--cloud);
            transition: background 0.15s;
        }
        .pod-ep:last-child { border-bottom: none; }
        .pod-ep:hover { background: #f0f3f7; }
        .pod-ep-rank {
            width: 28px; height: 28px; border-radius: 50%;
            background: var(--navy); color: var(--pure-white);
            font-size: 12px; font-weight: 700; display: flex;
            align-items: center; justify-content: center; flex-shrink: 0;
        }
        .pod-ep-info { flex: 1; min-width: 0; }
        .pod-ep-title {
            font-size: 13px; font-weight: 600; color: var(--navy);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .pod-ep-date { font-size: 11px; color: var(--steel); margin-top: 2px; }
        .pod-ep-stats { text-align: right; flex-shrink: 0; }
        .pod-ep-total { font-size: 15px; font-weight: 700; color: var(--navy); }
        .pod-ep-breakdown { font-size: 11px; color: var(--steel); margin-top: 2px; }
        .pod-ep-bar-wrap {
            width: 100px; height: 8px; background: var(--cloud);
            border-radius: 4px; overflow: hidden; flex-shrink: 0;
        }
        .pod-ep-bar {
            height: 100%; border-radius: 4px; background: linear-gradient(90deg, var(--accent), var(--accent-light));
            transition: width 0.3s ease;
        }
        .pod-trend-up { color: var(--green); }
        .pod-trend-down { color: var(--red); }
        .pod-controls { display: flex; align-items: center; gap: 10px; }
        .pod-controls select {
            font-family: 'Inter', sans-serif; font-size: 12px; font-weight: 500;
            padding: 6px 12px; border-radius: 6px; border: 1px solid var(--cloud);
            background: var(--pure-white); color: var(--navy); cursor: pointer;
        }

        /* ---- Toast ---- */
        .toast {
            position: fixed; bottom: 28px; right: 28px; padding: 14px 24px; border-radius: var(--radius);
            font-size: 13px; font-weight: 500; z-index: 1000; opacity: 0; transition: all 0.3s ease;
            pointer-events: none; box-shadow: var(--shadow-lg); color: var(--pure-white); backdrop-filter: blur(8px);
        }
        .toast.show { opacity: 1; }
        .toast.error { background: var(--red); }
        .toast.success { background: var(--navy); border-left: 4px solid var(--accent); }

        /* ---- Password Gate ---- */
        .pw-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 9999;
            background: linear-gradient(135deg, var(--navy) 0%, #0f1720 100%);
            display: flex; align-items: center; justify-content: center;
        }
        .pw-overlay.hidden { display: none; }
        .pw-card {
            background: var(--pure-white); border-radius: 16px; padding: 48px 40px;
            text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 380px; width: 90%;
        }
        .pw-card img { width: 56px; height: 56px; border-radius: 14px; margin-bottom: 20px; }
        .pw-card h2 { font-size: 20px; font-weight: 700; color: var(--navy); margin-bottom: 4px; }
        .pw-card .pw-sub { font-size: 13px; color: var(--steel); margin-bottom: 24px; }
        .pw-card input {
            width: 100%; padding: 12px 16px; border: 1px solid var(--cloud); border-radius: 8px;
            font-size: 16px; font-family: 'Inter', sans-serif; text-align: center;
            letter-spacing: 4px; transition: all 0.2s ease; color: var(--navy);
        }
        .pw-card input:focus { border-color: var(--accent); outline: none; box-shadow: 0 0 0 3px rgba(201,149,60,0.15); }
        .pw-card input.pw-error { border-color: var(--red); box-shadow: 0 0 0 3px rgba(192,57,43,0.1); animation: shake 0.4s ease; }
        .pw-card button {
            width: 100%; margin-top: 16px; padding: 12px; border: none; border-radius: 8px;
            background: var(--navy); color: var(--pure-white); font-size: 14px; font-weight: 600;
            font-family: 'Inter', sans-serif; cursor: pointer; letter-spacing: 0.5px;
            text-transform: uppercase; transition: background 0.2s ease;
        }
        .pw-card button:hover { background: var(--navy-light); }
        .pw-err-msg { font-size: 12px; color: var(--red); margin-top: 10px; min-height: 18px; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-6px); }
            75% { transform: translateX(6px); }
        }
        .app-wrapper { display: none; }
        .app-wrapper.visible { display: block; }
    </style>
</head>
<body>

<!-- Password Gate -->
<div class="pw-overlay" id="pwOverlay">
    <div class="pw-card">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%234a6fa5'/%3E%3Crect x='15' y='40' width='12' height='30' rx='2' fill='%23e0e0e0'/%3E%3Crect x='30' y='30' width='12' height='40' rx='2' fill='%23f0f0f0'/%3E%3Crect x='45' y='20' width='12' height='50' rx='2' fill='%23e0e0e0'/%3E%3Crect x='60' y='35' width='12' height='35' rx='2' fill='%23f0f0f0'/%3E%3Crect x='75' y='25' width='12' height='45' rx='2' fill='%23e0e0e0'/%3E%3Ccircle cx='50' cy='50' r='42' fill='none' stroke='%23c9953c' stroke-width='2.5' stroke-dasharray='6 4' opacity='.6'/%3E%3Ccircle cx='22' cy='18' r='3' fill='%23c9953c'/%3E%3Ccircle cx='78' cy='15' r='2.5' fill='%23e0b05e'/%3E%3Ccircle cx='85' cy='55' r='2' fill='%23c9953c'/%3E%3C/svg%3E" alt="Big Technology">
        <h2>Big Technology</h2>
        <div class="pw-sub">Video Production Tracker</div>
        <input type="password" id="pwInput" placeholder="Enter password" autofocus>
        <button onclick="checkPassword()">Unlock</button>
        <div class="pw-err-msg" id="pwError"></div>
    </div>
</div>

<div class="app-wrapper" id="appWrapper">
<div class="header">
    <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%234a6fa5'/%3E%3Crect x='15' y='40' width='12' height='30' rx='2' fill='%23e0e0e0'/%3E%3Crect x='30' y='30' width='12' height='40' rx='2' fill='%23f0f0f0'/%3E%3Crect x='45' y='20' width='12' height='50' rx='2' fill='%23e0e0e0'/%3E%3Crect x='60' y='35' width='12' height='35' rx='2' fill='%23f0f0f0'/%3E%3Crect x='75' y='25' width='12' height='45' rx='2' fill='%23e0e0e0'/%3E%3Ccircle cx='50' cy='50' r='42' fill='none' stroke='%23c9953c' stroke-width='2.5' stroke-dasharray='6 4' opacity='.6'/%3E%3Ccircle cx='22' cy='18' r='3' fill='%23c9953c'/%3E%3Ccircle cx='78' cy='15' r='2.5' fill='%23e0b05e'/%3E%3Ccircle cx='85' cy='55' r='2' fill='%23c9953c'/%3E%3C/svg%3E" alt="Big Technology" class="header-logo">
    <div class="header-text">
        <h1>Big Technology</h1>
        <div class="subtitle" id="headerSubtitle">Video Production Tracker</div>
    </div>
</div>

<!-- Month Switcher Bar -->
<div class="month-bar" id="monthBar"></div>

<div class="tabs">
    <div class="tab active" data-tab="videos">Videos</div>
    <div class="tab" data-tab="dashboard">Dashboard</div>
    <div class="tab" data-tab="videoperf">Video Performance</div>
    <div class="tab" data-tab="thumbperf">Thumbnail Performance</div>
    <div class="tab" data-tab="subgrowth">Sub Growth</div>
    <div class="tab" data-tab="podcast">Podcast</div>
    <div class="tab" data-tab="newsbriefs">News Briefs</div>
    <div class="tab" data-tab="newmonth">New Month</div>
    <div class="tab" data-tab="settings">Email Settings</div>
</div>

<div class="content">
    <!-- Videos Tab -->
    <div id="videos" class="tab-content active">
        <div class="stats-bar" id="statsBar"></div>
        <div class="toolbar">
            <button class="btn btn-primary" onclick="addRow()">+ Add Video</button>
            <button class="btn btn-danger" onclick="deleteSelected()">Delete Selected</button>
            <button class="btn btn-email" onclick="emailSelected()">Email Selected</button>
            <button class="btn btn-accent" onclick="saveNow()" id="saveBtn">üíæ Save</button>
            <button class="btn btn-secondary" onclick="testCloudSync()" id="testSyncBtn" title="Test if cloud sync is working">üîç Test Sync</button>
        </div>
        <div class="table-wrap">
            <table>
                <thead>
                    <tr>
                        <th class="col-checkbox"><input type="checkbox" id="selectAll" title="Select all"></th>
                        <th>Video Name</th>
                        <th>Short/Longform</th>
                        <th>Date Submitted</th>
                        <th>Post Date</th>
                        <th>Title</th>
                        <th>Thumbnails</th>
                        <th>Thumb Made</th>
                        <th>Description</th>
                        <th>First Edit</th>
                        <th>Approved</th>
                        <th>Posted</th>
                        <th>Time Code</th>
                        <th>Source Link</th>
                        <th>Notes</th>
                        <th>GDrive Link</th>
                        <th class="col-email">Email</th>
                    </tr>
                </thead>
                <tbody id="videoTableBody"></tbody>
            </table>
        </div>
    </div>

    <!-- Dashboard Tab -->
    <div id="dashboard" class="tab-content">
        <div class="dash-grid">
            <div class="dash-card dash-yt">
                <div class="dash-card-header">
                    <span class="dash-card-icon">‚ñ∂</span>
                    <h3>YouTube</h3>
                </div>
                <div class="dash-yt-stats">
                    <div class="dash-big-stat">
                        <div class="dash-big-number" id="ytSubCount">‚Äî</div>
                        <div class="dash-big-label">Subscribers</div>
                    </div>
                    <div class="dash-yt-row">
                        <div class="dash-mini-stat">
                            <div class="dash-mini-number" id="ytVideoCount">‚Äî</div>
                            <div class="dash-mini-label">Total Videos</div>
                        </div>
                        <div class="dash-mini-stat">
                            <div class="dash-mini-number" id="ytViewCount">‚Äî</div>
                            <div class="dash-mini-label">Total Views</div>
                        </div>
                    </div>
                </div>
                <div class="dash-yt-trajectory" id="ytTrajectory"></div>
                <div class="dash-yt-updated" id="ytUpdated"></div>
            </div>
            <div class="dash-card dash-alltime">
                <div class="dash-card-header">
                    <span class="dash-card-icon">üìä</span>
                    <h3>All-Time Production</h3>
                </div>
                <div class="dash-alltime-grid" id="dashAlltimeStats"></div>
            </div>
            <div class="dash-card dash-monthly-breakdown">
                <div class="dash-card-header">
                    <span class="dash-card-icon">üìÖ</span>
                    <h3>Monthly Breakdown</h3>
                </div>
                <div class="dash-months-table" id="dashMonthsTable"></div>
            </div>
        </div>
    </div>

    <!-- Video Performance Tab -->
    <div id="videoperf" class="tab-content">
        <div id="vpContainer">
            <div class="vp-loading" id="vpLoading">
                <div class="spinner"></div>
                Loading video performance data...
            </div>
        </div>
    </div>

    <!-- Thumbnail Performance Tab -->
    <div id="thumbperf" class="tab-content">
        <div id="tpContainer">
            <div class="vp-loading" id="tpLoading">
                <div class="spinner"></div>
                Loading thumbnail performance data...
            </div>
        </div>
    </div>

    <!-- Sub Growth Tab -->
    <div id="subgrowth" class="tab-content">
        <div id="sgContainer">
            <div class="vp-loading" id="sgLoading">
                <div class="spinner"></div>
                Loading subscriber growth data...
            </div>
        </div>
    </div>

    <!-- Podcast Analytics Tab -->
    <div id="podcast" class="tab-content">
        <div id="podContainer">
            <div class="vp-loading" id="podLoading">
                <div class="spinner"></div>
                Loading podcast analytics...
            </div>
        </div>
    </div>

    <!-- News Briefs Tab -->
    <div id="newsbriefs" class="tab-content">
        <div id="nbContainer">
            <div class="vp-loading" id="nbLoading">
                <div class="spinner"></div>
                Loading news briefs...
            </div>
        </div>
    </div>

    <!-- New Month Tab -->
    <div id="newmonth" class="tab-content">
        <div class="new-month-card">
            <h2>Create New Month</h2>
            <p>Start a fresh tracker for a new month. This creates an empty video list you can switch to at any time. Previous months are preserved.</p>
            <div class="month-select-row">
                <select id="newMonthSelect">
                    <option value="January">January</option>
                    <option value="February">February</option>
                    <option value="March">March</option>
                    <option value="April">April</option>
                    <option value="May">May</option>
                    <option value="June">June</option>
                    <option value="July">July</option>
                    <option value="August">August</option>
                    <option value="September">September</option>
                    <option value="October">October</option>
                    <option value="November">November</option>
                    <option value="December">December</option>
                </select>
                <input type="number" id="newYearInput" value="2026" min="2024" max="2030" style="max-width:100px;">
            </div>
            <button class="btn btn-accent" onclick="createNewMonth()">Create Month</button>
        </div>
    </div>

    <!-- Email Settings Tab -->
    <div id="settings" class="tab-content">
        <div class="settings-card">
            <div class="settings-section">
                <h2>Email Recipients</h2>
                <p>When you check the Email box on a video, it will be sent to all addresses listed here.</p>
                <div id="emailList" class="email-list"></div>
                <div style="display:flex; gap:10px; align-items:center; margin-top:12px; flex-wrap:wrap;">
                    <button class="btn btn-primary" onclick="addEmailField()">+ Add Email</button>
                    <button class="btn btn-secondary" onclick="testEmail()">Send Test Email</button>
                    <span id="emailStatus"></span>
                </div>
                <div style="margin-top:12px; padding:12px 16px; background:rgba(226,166,49,0.1); border:1px solid rgba(226,166,49,0.3); border-radius:8px; font-size:0.85rem; color:#94a3b8;">
                    <strong style="color:#e2a631;">üí° Cloud Sync:</strong> Email settings are automatically synced to the cloud. They'll persist across browsers and devices ‚Äî no bookmarking needed.
                </div>
            </div>
        </div>
    </div>
</div>

<div class="toast" id="toast"></div>
</div><!-- end app-wrapper -->

<script>
// ---- Password Gate ----
const PW_HASH = 'a5ccb1c538e34663a658b1be28b16455ee5285efb10e6f1d4caba1f69ec9782b'; // SHA-256 of "911"
const PW_SESSION_KEY = 'bigtech_auth';

async function sha256(str) {
    const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(str));
    return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2,'0')).join('');
}

async function checkPassword() {
    const input = document.getElementById('pwInput');
    const hash = await sha256(input.value);
    if (hash === PW_HASH) {
        sessionStorage.setItem(PW_SESSION_KEY, 'true');
        unlockApp();
    } else {
        input.classList.add('pw-error');
        document.getElementById('pwError').textContent = 'Incorrect password';
        setTimeout(() => input.classList.remove('pw-error'), 400);
        input.value = '';
        input.focus();
    }
}

function unlockApp() {
    document.getElementById('pwOverlay').classList.add('hidden');
    document.getElementById('appWrapper').classList.add('visible');
}

// Check if already authenticated this session
if (sessionStorage.getItem(PW_SESSION_KEY) === 'true') {
    unlockApp();
}

// Allow Enter key to submit
document.getElementById('pwInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') checkPassword();
});
// ---- Constants ----
const MONTHS_KEY = 'bigtech_months';      // { months: [{id, label, videos}], activeMonthId }
const SETTINGS_KEY = 'bigtech_settings';
const LEGACY_KEY = 'bigtech_videos';

const MONTH_NAMES = ['January','February','March','April','May','June','July','August','September','October','November','December'];

// ---- Cloud Sync (npoint.io) ----
const NPOINT_URL = 'https://api.npoint.io/aacc4d4f83658845c610';

let cloudSyncEnabled = !!NPOINT_URL;
let isSyncing = false;
let syncQueue = null; // holds pending save if one is in-flight

async function fetchFromCloud() {
    if (!cloudSyncEnabled) return null;
    try {
        // Cache-bust: add timestamp param to defeat Cloudflare/browser caching
        const url = NPOINT_URL + '?t=' + Date.now();
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        // Normalize all videos
        if (data.months) {
            data.months.forEach(m => {
                m.videos = (m.videos || []).map(normalizeVideo);
            });
        }
        return data;
    } catch (err) {
        console.warn('Cloud fetch failed, using local cache:', err);
        return null;
    }
}

async function saveToCloud(data) {
    if (!cloudSyncEnabled) return;
    // If already syncing, queue this save (latest wins)
    if (isSyncing) {
        syncQueue = JSON.parse(JSON.stringify(data)); // deep copy
        console.log('[SYNC] Queued save (already syncing)');
        return;
    }
    isSyncing = true;
    updateSyncBadge('saving');
    try {
        const body = JSON.stringify(data);
        console.log('[SYNC] Saving to cloud...', body.length, 'bytes');
        const res = await fetch(NPOINT_URL, {
            method: 'POST',
            cache: 'no-store',
            headers: { 'Content-Type': 'application/json' },
            body: body
        });
        if (!res.ok) {
            const errText = await res.text();
            throw new Error(`HTTP ${res.status}: ${errText}`);
        }
        const responseData = await res.json();
        console.log('[SYNC] Cloud save OK, response:', JSON.stringify(responseData).substring(0, 200));
        updateSyncBadge('saved');
    } catch (err) {
        console.error('[SYNC] Cloud save FAILED:', err);
        updateSyncBadge('error');
        // Show visible error so user knows sync failed
        toast('Cloud sync failed: ' + err.message, 'error');
    } finally {
        isSyncing = false;
        // Process queued save if any
        if (syncQueue) {
            const queued = syncQueue;
            syncQueue = null;
            saveToCloud(queued);
        }
    }
}

function updateSyncBadge(state) {
    let badge = document.getElementById('syncBadge');
    if (!badge) {
        badge = document.createElement('div');
        badge.id = 'syncBadge';
        badge.style.cssText = 'position:fixed;top:8px;right:8px;z-index:9999;padding:4px 10px;border-radius:12px;font-size:11px;font-weight:600;font-family:Inter,sans-serif;transition:all 0.3s;pointer-events:none;';
        document.body.appendChild(badge);
    }
    if (state === 'saving') {
        badge.textContent = '‚òÅÔ∏è Saving...';
        badge.style.background = '#2563eb'; badge.style.color = '#fff'; badge.style.opacity = '1';
    } else if (state === 'saved') {
        badge.textContent = '‚úÖ Saved';
        badge.style.background = '#16a34a'; badge.style.color = '#fff'; badge.style.opacity = '1';
        setTimeout(() => badge.style.opacity = '0', 2000);
    } else if (state === 'error') {
        badge.textContent = '‚ùå Sync Error';
        badge.style.background = '#dc2626'; badge.style.color = '#fff'; badge.style.opacity = '1';
        setTimeout(() => badge.style.opacity = '0', 5000);
    }
}

// ---- Data Layer ----
const DEFAULT_VIDEOS = [
    { id:1, videoName:'Bret Taylor', type:'Short', dateSubmitted:'', postDate:'2-9', title:'Is AI The Last Invention?', thumbnails:'', thumbnailMade:false, description:'', firstEdit:'Yes', approved:'Yes', posted:'Yes', timeCode:'27:20 - 28:51', sourceLink:'', notes:'', gdriveLink:'https://drive.google.com/file/d/1o5fSXUdP5' },
    { id:2, videoName:'Bret Taylor Clip 01', type:'Clip', dateSubmitted:'', postDate:'', title:'Lessons From', thumbnails:'', thumbnailMade:false, description:'', firstEdit:'Yes', approved:'Yes', posted:'Yes', timeCode:'', sourceLink:'', notes:'', gdriveLink:'' },
    { id:3, videoName:'Ranjan 2-6', type:'Longform', dateSubmitted:'2-6', postDate:'', title:'', thumbnails:'', thumbnailMade:false, description:'', firstEdit:'Yes', approved:'Yes', posted:'Yes', timeCode:'', sourceLink:'https://riverside.com/dashboard/studios/ranjan-fridays/projects/69863e3048431', notes:'', gdriveLink:'' },
    { id:4, videoName:'Karthik Kripapuri', type:'Longform', dateSubmitted:'', postDate:'', title:'CEO, Promevo', thumbnails:'', thumbnailMade:false, description:'', firstEdit:'Yes', approved:'Yes', posted:'Yes', timeCode:'', sourceLink:'https://riverside.com/dashboard/studios/promevo-2-4/projects/6982b4ee3ed00c', notes:'', gdriveLink:'' },
    { id:5, videoName:'Sridhar Ramaswamy', type:'Longform', dateSubmitted:'2-5', postDate:'2-7', title:'CEO, Snowflake', thumbnails:'', thumbnailMade:false, description:'', firstEdit:'Yes', approved:'Yes', posted:'Yes', timeCode:'', sourceLink:'https://drive.google.com/drive/folders/1VA5D8WD6AlI6W_Vye4INyO2SoOuvsxr-', notes:'', gdriveLink:'https://drive.google.com/file/d/1_dILA5VB6e' }
];

function normalizeVideo(v) {
    return Object.assign({ thumbnailMade: false }, v);
}

function loadMonthsData() {
    const raw = localStorage.getItem(MONTHS_KEY);
    if (raw) {
        const data = JSON.parse(raw);
        data.months.forEach(m => {
            m.videos = (m.videos || []).map(normalizeVideo);
        });
        return data;
    }

    // Migrate legacy data ‚Äî save to localStorage ONLY (not cloud)
    // Cloud sync happens later in syncOnLoad to avoid race conditions
    const legacyRaw = localStorage.getItem(LEGACY_KEY);
    const legacyVideos = legacyRaw ? JSON.parse(legacyRaw) : DEFAULT_VIDEOS.map(d => ({...d}));

    const data = {
        months: [{ id: 'feb-2026', label: 'February 2026', videos: legacyVideos.map(normalizeVideo) }],
        activeMonthId: 'feb-2026'
    };
    localStorage.setItem(MONTHS_KEY, JSON.stringify(data));
    return data;
}

function saveMonthsData(data) {
    // Stamp with modification time so sync can compare
    data.lastModified = Date.now();
    // Always save to localStorage (fast cache)
    localStorage.setItem(MONTHS_KEY, JSON.stringify(data));
    // Also push to cloud (async, non-blocking)
    saveToCloud(data);
}

async function saveNow() {
    const btn = document.getElementById('saveBtn');
    btn.textContent = '‚è≥ Saving...';
    btn.disabled = true;
    try {
        const data = loadMonthsData();
        data.settings = loadSettings();
        data.lastModified = Date.now();
        localStorage.setItem(MONTHS_KEY, JSON.stringify(data));
        await saveToCloud(data);

        // Verify the save by reading back
        const verify = await fetchFromCloud();
        if (verify && verify.months && verify.months.length > 0) {
            const cloudVids = verify.months.reduce((s, m) => s + m.videos.length, 0);
            const localVids = data.months.reduce((s, m) => s + m.videos.length, 0);
            if (cloudVids === localVids) {
                btn.textContent = '‚úÖ Verified!';
                toast('Saved & verified ‚Äî ' + localVids + ' videos in cloud', 'success');
            } else {
                btn.textContent = '‚ö†Ô∏è Mismatch';
                toast('Saved but cloud has ' + cloudVids + ' videos vs local ' + localVids, 'error');
            }
        } else {
            btn.textContent = '‚ö†Ô∏è Unverified';
            toast('Save sent but could not verify ‚Äî cloud returned empty', 'error');
        }
    } catch (err) {
        btn.textContent = '‚ùå Error';
        toast('Save failed: ' + err.message, 'error');
    }
    setTimeout(() => { btn.textContent = 'üíæ Save'; btn.disabled = false; }, 3000);
}

async function testCloudSync() {
    const btn = document.getElementById('testSyncBtn');
    btn.textContent = '‚è≥ Testing...'; btn.disabled = true;
    const results = [];
    try {
        // Step 1: Write current data to cloud
        const data = loadMonthsData();
        data.settings = loadSettings();
        data.lastModified = Date.now();
        const body = JSON.stringify(data);
        results.push('üì§ Sending ' + body.length + ' bytes...');

        const writeRes = await fetch(NPOINT_URL, {
            method: 'POST',
            cache: 'no-store',
            headers: { 'Content-Type': 'application/json' },
            body: body
        });
        results.push('üì§ POST response: HTTP ' + writeRes.status);
        if (!writeRes.ok) {
            const errText = await writeRes.text();
            results.push('‚ùå POST failed: ' + errText);
            alert('SYNC TEST RESULTS:\n\n' + results.join('\n'));
            return;
        }
        const writeData = await writeRes.json();
        results.push('üì§ POST returned ' + JSON.stringify(writeData).length + ' bytes');

        // Step 2: Read back from cloud
        const readUrl = NPOINT_URL + '?t=' + Date.now();
        const readRes = await fetch(readUrl, { cache: 'no-store' });
        results.push('üì• GET response: HTTP ' + readRes.status);
        const readData = await readRes.json();
        const cloudMonths = readData.months ? readData.months.length : 0;
        const cloudVideos = readData.months && readData.months[0] ? readData.months[0].videos.length : 0;
        results.push('üì• Cloud has: ' + cloudMonths + ' months, ' + cloudVideos + ' videos');
        results.push('üì• lastModified: ' + readData.lastModified);

        // Step 3: Compare
        const localVideos = data.months && data.months[0] ? data.months[0].videos.length : 0;
        if (cloudVideos === localVideos) {
            results.push('‚úÖ SYNC WORKING! Cloud matches local (' + localVideos + ' videos)');
            toast('Cloud sync verified! Data is saving correctly.', 'success');
        } else {
            results.push('‚ö†Ô∏è MISMATCH: Local has ' + localVideos + ' videos, cloud has ' + cloudVideos);
            toast('Sync mismatch detected ‚Äî see alert', 'error');
        }
    } catch (err) {
        results.push('‚ùå ERROR: ' + err.message);
        toast('Sync test failed: ' + err.message, 'error');
    }
    alert('SYNC TEST RESULTS:\n\n' + results.join('\n'));
    btn.textContent = 'üîç Test Sync'; btn.disabled = false;
}

function getActiveMonth() {
    const data = loadMonthsData();
    return data.months.find(m => m.id === data.activeMonthId) || data.months[0];
}

const DEFAULT_SETTINGS = {
    emails: [''],
    ejsPublicKey: 'jBbJUBVfCXMatjt7w',
    ejsServiceId: 'service_uhjvpdb',
    ejsTemplateId: 'template_204ttnj'
};

// ---- Settings (persisted to Cloudflare KV via Worker) ----
function loadSettings() {
    // Priority: 1) localStorage cache, 2) cloud data settings, 3) defaults
    const raw = localStorage.getItem(SETTINGS_KEY);
    if (raw) {
        const saved = JSON.parse(raw);
        return {
            emails: saved.emails || DEFAULT_SETTINGS.emails,
            ejsPublicKey: saved.ejsPublicKey || DEFAULT_SETTINGS.ejsPublicKey,
            ejsServiceId: saved.ejsServiceId || DEFAULT_SETTINGS.ejsServiceId,
            ejsTemplateId: saved.ejsTemplateId || DEFAULT_SETTINGS.ejsTemplateId
        };
    }
    // Check if settings exist in cloud data (stored alongside months)
    const monthsRaw = localStorage.getItem(MONTHS_KEY);
    if (monthsRaw) {
        const monthsData = JSON.parse(monthsRaw);
        if (monthsData.settings) {
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(monthsData.settings));
            return {
                emails: monthsData.settings.emails || DEFAULT_SETTINGS.emails,
                ejsPublicKey: monthsData.settings.ejsPublicKey || DEFAULT_SETTINGS.ejsPublicKey,
                ejsServiceId: monthsData.settings.ejsServiceId || DEFAULT_SETTINGS.ejsServiceId,
                ejsTemplateId: monthsData.settings.ejsTemplateId || DEFAULT_SETTINGS.ejsTemplateId
            };
        }
    }
    return { ...DEFAULT_SETTINGS, emails: [''] };
}

async function fetchSettingsFromWorker() {
    try {
        const res = await fetch(NB_WORKER_URL + '/settings', { cache: 'no-store' });
        if (!res.ok) return null;
        const data = await res.json();
        if (data && (data.emails || data.ejsPublicKey)) {
            return data;
        }
        return null;
    } catch (e) {
        console.warn('[Settings] Worker fetch failed:', e.message);
        return null;
    }
}

async function saveSettingsToWorker(settings) {
    try {
        const res = await fetch(NB_WORKER_URL + '/settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ settings })
        });
        if (!res.ok) console.warn('[Settings] Worker save error:', res.status);
    } catch (e) {
        console.warn('[Settings] Worker save failed:', e.message);
    }
}

function saveSettingsData(settings) {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    // Sync to Worker KV (async, non-blocking)
    saveSettingsToWorker(settings);
    // Also sync settings to npoint cloud
    const data = loadMonthsData();
    data.settings = settings;
    data.lastModified = Date.now();
    localStorage.setItem(MONTHS_KEY, JSON.stringify(data));
    saveToCloud(data);
}

let videos = [];
let nextId = 1;

function loadActiveVideos() {
    const month = getActiveMonth();
    videos = month.videos;
    nextId = Math.max(...videos.map(v => v.id), 0) + 1;
}

function saveActiveVideos() {
    const data = loadMonthsData();
    const month = data.months.find(m => m.id === data.activeMonthId);
    if (month) { month.videos = videos; saveMonthsData(data); }
}

// ---- Month Management ----
function renderMonthBar() {
    const data = loadMonthsData();
    const bar = document.getElementById('monthBar');
    bar.innerHTML = '';

    data.months.forEach(m => {
        const pill = document.createElement('button');
        pill.className = 'month-pill' + (m.id === data.activeMonthId ? ' active' : '');
        pill.textContent = m.label;
        pill.onclick = () => switchMonth(m.id);

        // Add delete button for non-active months (only if more than 1 month)
        if (data.months.length > 1 && m.id !== data.activeMonthId) {
            const del = document.createElement('span');
            del.className = 'month-delete';
            del.textContent = '\u00d7';
            del.onclick = (e) => { e.stopPropagation(); deleteMonth(m.id); };
            pill.appendChild(del);
        }

        bar.appendChild(pill);
    });
}

function switchMonth(monthId) {
    const data = loadMonthsData();
    data.activeMonthId = monthId;
    saveMonthsData(data);
    loadActiveVideos();
    renderMonthBar();
    renderTable();
    updateStats();
    updateSubtitle();
}

function createNewMonth() {
    const monthName = document.getElementById('newMonthSelect').value;
    const year = document.getElementById('newYearInput').value;
    const label = `${monthName} ${year}`;
    const id = `${monthName.toLowerCase()}-${year}`;

    const data = loadMonthsData();

    if (data.months.find(m => m.id === id)) {
        toast(`${label} already exists. Select it from the month bar.`, 'error');
        return;
    }

    data.months.push({ id, label, videos: [] });
    data.activeMonthId = id;
    saveMonthsData(data);

    loadActiveVideos();
    renderMonthBar();
    renderTable();
    updateStats();
    updateSubtitle();

    // Switch to Videos tab
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    document.querySelector('[data-tab="videos"]').classList.add('active');
    document.getElementById('videos').classList.add('active');

    toast(`${label} created`, 'success');
}

function deleteMonth(monthId) {
    const data = loadMonthsData();
    const month = data.months.find(m => m.id === monthId);
    if (!month) return;
    if (!confirm(`Delete "${month.label}" and all its videos? This cannot be undone.`)) return;

    data.months = data.months.filter(m => m.id !== monthId);
    if (data.activeMonthId === monthId) {
        data.activeMonthId = data.months[0]?.id || '';
    }
    saveMonthsData(data);

    loadActiveVideos();
    renderMonthBar();
    renderTable();
    updateStats();
    updateSubtitle();
    toast(`${month.label} deleted`, 'success');
}

function updateSubtitle() {
    const month = getActiveMonth();
    document.getElementById('headerSubtitle').textContent = `Video Production Tracker \u2014 ${month.label}`;
}

// ---- Stats ----
function updateStats() {
    const longforms = videos.filter(v => v.type === 'Longform').length;
    const clips = videos.filter(v => v.type === 'Clip').length;
    const shorts = videos.filter(v => v.type === 'Short').length;
    const thumbsDone = videos.filter(v => v.thumbnailMade).length;
    const total = videos.length;

    document.getElementById('statsBar').innerHTML = `
        <div class="stat-card">
            <div class="stat-icon total">#</div>
            <div class="stat-info"><div class="stat-count">${total}</div><div class="stat-label">Total Videos</div></div>
        </div>
        <div class="stat-card">
            <div class="stat-icon longform">L</div>
            <div class="stat-info"><div class="stat-count">${longforms}</div><div class="stat-label">Longform</div></div>
        </div>
        <div class="stat-card">
            <div class="stat-icon clip">C</div>
            <div class="stat-info"><div class="stat-count">${clips}</div><div class="stat-label">Clips</div></div>
        </div>
        <div class="stat-card">
            <div class="stat-icon short">S</div>
            <div class="stat-info"><div class="stat-count">${shorts}</div><div class="stat-label">Shorts</div></div>
        </div>
        <div class="stat-card">
            <div class="stat-icon thumb">üñº</div>
            <div class="stat-info"><div class="stat-count">${thumbsDone}</div><div class="stat-label">Thumbnails</div></div>
        </div>
    `;
}

// ---- Table Rendering ----
function renderTable() {
    const tbody = document.getElementById('videoTableBody');
    tbody.innerHTML = '';
    videos.forEach((v) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td class="col-checkbox"><input type="checkbox" class="row-select" data-id="${v.id}"></td>
            <td><input type="text" value="${esc(v.videoName)}" data-field="videoName" data-id="${v.id}"></td>
            <td><select data-field="type" data-id="${v.id}">
                <option value="Short" ${v.type==='Short'?'selected':''}>Short</option>
                <option value="Longform" ${v.type==='Longform'?'selected':''}>Longform</option>
                <option value="Clip" ${v.type==='Clip'?'selected':''}>Clip</option>
            </select></td>
            <td><input type="text" value="${esc(v.dateSubmitted)}" data-field="dateSubmitted" data-id="${v.id}" placeholder="M-D"></td>
            <td><input type="text" value="${esc(v.postDate)}" data-field="postDate" data-id="${v.id}" placeholder="M-D"></td>
            <td><input type="text" value="${esc(v.title)}" data-field="title" data-id="${v.id}"></td>
            <td><input type="text" value="${esc(v.thumbnails)}" data-field="thumbnails" data-id="${v.id}"></td>
            <td class="check-col"><input type="checkbox" class="thumb-check" data-field="thumbnailMade" data-id="${v.id}" ${v.thumbnailMade ? 'checked' : ''}></td>
            <td><input type="text" value="${esc(v.description)}" data-field="description" data-id="${v.id}"></td>
            <td class="check-col"><select data-field="firstEdit" data-id="${v.id}">
                <option value="">-</option><option value="Yes" ${v.firstEdit==='Yes'?'selected':''}>Yes</option><option value="No" ${v.firstEdit==='No'?'selected':''}>No</option>
            </select></td>
            <td class="check-col"><select data-field="approved" data-id="${v.id}">
                <option value="">-</option><option value="Yes" ${v.approved==='Yes'?'selected':''}>Yes</option><option value="No" ${v.approved==='No'?'selected':''}>No</option>
            </select></td>
            <td class="check-col"><select data-field="posted" data-id="${v.id}">
                <option value="">-</option><option value="Yes" ${v.posted==='Yes'?'selected':''}>Yes</option><option value="No" ${v.posted==='No'?'selected':''}>No</option>
            </select></td>
            <td><input type="text" value="${esc(v.timeCode)}" data-field="timeCode" data-id="${v.id}" placeholder="0:00 - 0:00"></td>
            <td><input type="text" value="${esc(v.sourceLink)}" data-field="sourceLink" data-id="${v.id}" placeholder="URL"></td>
            <td><input type="text" value="${esc(v.notes)}" data-field="notes" data-id="${v.id}"></td>
            <td><input type="text" value="${esc(v.gdriveLink)}" data-field="gdriveLink" data-id="${v.id}" placeholder="URL"></td>
            <td class="col-email"><input type="checkbox" class="email-check" data-id="${v.id}" title="Send email with this video's details"></td>
        `;
        tbody.appendChild(tr);
    });

    applySelectColors(tbody);

    tbody.querySelectorAll('input[data-field], select[data-field]').forEach(el => {
        el.addEventListener('change', (e) => {
            handleFieldChange(e);
            applySelectColor(e.target);
            updateStats();
        });
        // Also save text fields on every keystroke (debounced)
        if (el.type === 'text') {
            let debounceTimer;
            el.addEventListener('input', (e) => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    handleFieldChange(e);
                    updateStats();
                }, 500);
            });
        }
    });

    tbody.querySelectorAll('.email-check').forEach(el => {
        el.addEventListener('change', handleEmailCheck);
    });

    // Re-apply column widths after re-render
    if (typeof initColumnResize === 'function') initColumnResize();
}

function esc(str) {
    if (!str) return '';
    return str.replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function applySelectColors(container) {
    container.querySelectorAll('select[data-field]').forEach(applySelectColor);
}

function applySelectColor(el) {
    if (!el || el.tagName !== 'SELECT') return;
    const field = el.dataset.field;
    const val = el.value;
    el.className = el.className.replace(/\bselect-\S+/g, '').trim();
    if (field === 'type') {
        if (val === 'Short') el.classList.add('select-short');
        else if (val === 'Clip') el.classList.add('select-clip');
        else if (val === 'Longform') el.classList.add('select-longform');
    } else if (field === 'firstEdit' || field === 'approved' || field === 'posted') {
        if (val === 'Yes') el.classList.add('select-yes');
        else if (val === 'No') el.classList.add('select-no');
        else el.classList.add('select-empty');
    }
}

function handleFieldChange(e) {
    const id = parseInt(e.target.dataset.id);
    const field = e.target.dataset.field;
    const value = e.target.type === 'checkbox' ? e.target.checked : e.target.value;
    const video = videos.find(v => v.id === id);
    if (video) { video[field] = value; saveActiveVideos(); }
}

function handleEmailCheck(e) {
    const id = parseInt(e.target.dataset.id);
    const video = videos.find(v => v.id === id);
    if (!video) return;
    if (e.target.checked) { sendVideoEmail([video], e.target); }
}

// ---- Row Management ----
function addRow() {
    const now = new Date();
    const todayStr = (now.getMonth()+1) + '-' + now.getDate();
    videos.push({
        id: nextId++, videoName: '', type: 'Longform', dateSubmitted: todayStr, postDate: '',
        title: '', thumbnails: '', thumbnailMade: false, description: '',
        firstEdit: '', approved: '', posted: '', timeCode: '',
        sourceLink: '', notes: '', gdriveLink: ''
    });
    saveActiveVideos();
    renderTable();
    updateStats();
    toast('New row added', 'success');
}

function deleteSelected() {
    const checked = document.querySelectorAll('.row-select:checked');
    if (checked.length === 0) { toast('No rows selected', 'error'); return; }
    if (!confirm(`Delete ${checked.length} selected row(s)?`)) return;
    const ids = new Set([...checked].map(c => parseInt(c.dataset.id)));
    videos = videos.filter(v => !ids.has(v.id));
    saveActiveVideos();
    renderTable();
    updateStats();
    toast(`${ids.size} row(s) deleted`, 'success');
}

function emailSelected() {
    const checked = document.querySelectorAll('.row-select:checked');
    if (checked.length === 0) { toast('No rows selected', 'error'); return; }
    const ids = new Set([...checked].map(c => parseInt(c.dataset.id)));
    const selected = videos.filter(v => ids.has(v.id));
    sendVideoEmail(selected, null);
}

// ---- Email Sending via EmailJS ----
function buildEmailHTML(videoList) {
    let html = '';
    videoList.forEach((v, i) => {
        if (videoList.length > 1) {
            html += `<hr style="border:none;border-top:1px solid #e0e0e0;margin:20px 0;">`;
            html += `<p style="font-size:14px;color:#888;margin-bottom:12px;">Video ${i+1}</p>`;
        }
        html += `<table style="font-family:'Inter',Helvetica,Arial,sans-serif;font-size:14px;color:#1a2332;border-collapse:collapse;width:100%;max-width:600px;">`;
        const fields = [
            ['Video Name', v.videoName], ['Type', v.type], ['Date Submitted', v.dateSubmitted],
            ['Post Date', v.postDate], ['Title', v.title], ['Thumbnails', v.thumbnails], ['Thumbnail Made', v.thumbnailMade ? 'Yes' : 'No'],
            ['Description', v.description], ['First Edit', v.firstEdit], ['Approved', v.approved],
            ['Posted', v.posted], ['Time Code', v.timeCode], ['Source Link', v.sourceLink],
            ['Notes', v.notes], ['GDrive Link', v.gdriveLink]
        ];
        fields.forEach(([label, value]) => {
            const isLink = (label === 'Source Link' || label === 'GDrive Link') && value;
            const valHtml = isLink
                ? `<a href="${esc(value)}" style="color:#4a90d9;text-decoration:none;">${esc(value)}</a>`
                : (value ? esc(value) : '<span style="color:#b8c5d1;">\u2014</span>');
            html += `<tr><td style="padding:6px 12px 6px 0;font-weight:700;white-space:nowrap;vertical-align:top;color:#1a2332;">${label}</td><td style="padding:6px 0;font-weight:400;color:#3d5068;">${valHtml}</td></tr>`;
        });
        html += `</table>`;
    });
    return html;
}

async function sendVideoEmail(videoList, checkboxEl) {
    const settings = loadSettings();
    const recipients = settings.emails.filter(e => e.trim() !== '');
    if (!settings.ejsPublicKey || !settings.ejsServiceId || !settings.ejsTemplateId) {
        toast('EmailJS not configured. Go to Email Settings tab.', 'error');
        if (checkboxEl) checkboxEl.checked = false; return;
    }
    if (recipients.length === 0) {
        toast('No email recipients configured. Go to Email Settings tab.', 'error');
        if (checkboxEl) checkboxEl.checked = false; return;
    }
    const parentTd = checkboxEl ? checkboxEl.parentElement : null;
    if (parentTd) parentTd.classList.add('sending');
    const names = videoList.map(v => v.videoName || 'Untitled').join(', ');
    const subject = `New Video: ${names}`;
    const message = buildEmailHTML(videoList);
    try {
        emailjs.init(settings.ejsPublicKey);
        await emailjs.send(settings.ejsServiceId, settings.ejsTemplateId, {
            to_emails: recipients.join(', '), subject: subject, message: message
        });
        toast(`Email sent for: ${names}`, 'success');
    } catch (err) {
        console.error('EmailJS error:', err);
        toast(`Email failed: ${err?.text || err?.message || 'Unknown error'}`, 'error');
    } finally {
        if (parentTd) parentTd.classList.remove('sending');
        if (checkboxEl) setTimeout(() => { checkboxEl.checked = false; }, 500);
    }
}

async function testEmail() {
    saveSettings();
    const statusEl = document.getElementById('emailStatus');
    const settings = loadSettings();
    if (!settings.ejsPublicKey || !settings.ejsServiceId || !settings.ejsTemplateId) {
        statusEl.innerHTML = '<span class="status-badge status-err">Missing EmailJS credentials</span>'; return;
    }
    const recipients = settings.emails.filter(e => e.trim() !== '');
    if (recipients.length === 0) { statusEl.innerHTML = '<span class="status-badge status-err">No recipients</span>'; return; }
    statusEl.innerHTML = '<span class="status-badge status-warn">Sending test...</span>';
    try {
        emailjs.init(settings.ejsPublicKey);
        await emailjs.send(settings.ejsServiceId, settings.ejsTemplateId, {
            to_emails: recipients.join(', '), subject: 'New Video: Test Video',
            message: '<p style="font-family:Inter,Helvetica,Arial,sans-serif;font-size:14px;color:#1a2332;">This is a test email from <strong>Big Technology Video Tracker</strong>.</p><p style="font-family:Inter,Helvetica,Arial,sans-serif;font-size:14px;color:#3d5068;">If you received this, your email configuration is working correctly.</p>'
        });
        statusEl.innerHTML = '<span class="status-badge status-ok">Test email sent!</span>';
    } catch (err) {
        console.error('Test email error:', err);
        statusEl.innerHTML = `<span class="status-badge status-err">Failed: ${err?.text || err?.message || 'Unknown error'}</span>`;
    }
}

// ---- Email Settings ----
function renderSettings() {
    const settings = loadSettings();
    const container = document.getElementById('emailList');
    container.innerHTML = '';
    settings.emails.forEach((email, i) => {
        const row = document.createElement('div');
        row.className = 'email-row';
        row.innerHTML = `
            <input type="email" value="${esc(email)}" placeholder="name@example.com" data-idx="${i}" class="email-input">
            <button class="remove-email" onclick="removeEmail(${i})" title="Remove">&times;</button>
        `;
        container.appendChild(row);
    });
    container.querySelectorAll('.email-input').forEach(el => {
        el.addEventListener('input', () => {
            const s = loadSettings();
            s.emails[parseInt(el.dataset.idx)] = el.value;
            saveSettingsData(s);
        });
    });
}

function addEmailField() {
    const settings = loadSettings();
    settings.emails.push('');
    saveSettingsData(settings);
    renderSettings();
}

function removeEmail(idx) {
    const settings = loadSettings();
    settings.emails.splice(idx, 1);
    if (settings.emails.length === 0) settings.emails.push('');
    saveSettingsData(settings);
    renderSettings();
}

function saveSettings() {
    const settings = loadSettings();
    // EmailJS credentials are hardcoded in DEFAULT_SETTINGS ‚Äî just save email list
    saveSettingsData(settings);
    toast('Settings saved', 'success');
}

// ---- Tabs ----
document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(tab.dataset.tab).classList.add('active');
        if (tab.dataset.tab === 'dashboard') renderDashboard();
        if (tab.dataset.tab === 'videoperf') renderVideoPerformance();
        if (tab.dataset.tab === 'thumbperf') renderThumbnailPerformance();
        if (tab.dataset.tab === 'subgrowth') renderSubGrowth();
        if (tab.dataset.tab === 'podcast') renderPodcast();
        if (tab.dataset.tab === 'newsbriefs') loadNewsBriefs();
    });
});

document.getElementById('selectAll').addEventListener('change', function() {
    document.querySelectorAll('.row-select').forEach(cb => cb.checked = this.checked);
});

// ---- Dashboard ----
const YT_CHANNEL_ID = 'UCye1YedIypHffYb8k6Gp9wg';
const YT_API_KEY = 'AIzaSyDHSKE85zh7z_YZ-crCya2YMrFF0SlmIlA';

function formatNumber(n) {
    if (!n) return '‚Äî';
    const num = parseInt(n);
    if (num >= 1000000) return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
    return num.toLocaleString();
}

async function fetchYouTubeStats() {
    try {
        const res = await fetch(`https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${YT_CHANNEL_ID}&key=${YT_API_KEY}`);
        const data = await res.json();
        if (data.items && data.items[0]) {
            const stats = data.items[0].statistics;
            const snippet = data.items[0].snippet;
            document.getElementById('ytSubCount').textContent = formatNumber(stats.subscriberCount);
            document.getElementById('ytVideoCount').textContent = formatNumber(stats.videoCount);
            document.getElementById('ytViewCount').textContent = formatNumber(stats.viewCount);
            document.getElementById('ytUpdated').textContent = 'Updated just now';

            // 100K Subscriber Trajectory ‚Äî based on recent growth, not all-time
            // Known data point from YouTube Studio: ~17,000 subs in Feb 2025
            const subs = parseInt(stats.subscriberCount);
            const now = new Date();
            const anchor = { date: new Date('2025-02-01'), subs: 17000 };
            const monthsSinceAnchor = (now - anchor.date) / (1000 * 60 * 60 * 24 * 30.44);
            const recentGrowth = subs - anchor.subs;
            const subsPerMonth = monthsSinceAnchor > 0 ? recentGrowth / monthsSinceAnchor : 0;
            const subsNeeded = 100000 - subs;
            const trajEl = document.getElementById('ytTrajectory');

            if (subs >= 100000) {
                trajEl.innerHTML = `
                    <div class="dash-traj-label">üéâ 100,000 Subscriber Trajectory</div>
                    <div class="dash-traj-date">Already reached!</div>
                `;
            } else if (subsPerMonth > 0) {
                const monthsToGo = subsNeeded / subsPerMonth;
                const targetDate = new Date(now.getTime() + monthsToGo * 30.44 * 24 * 60 * 60 * 1000);
                const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
                const dateStr = monthNames[targetDate.getMonth()] + ' ' + targetDate.getFullYear();
                trajEl.innerHTML = `
                    <div class="dash-traj-label">üéØ 100,000 Subscriber Trajectory</div>
                    <div class="dash-traj-date">${dateStr}</div>
                    <div class="dash-traj-sub">Growing ~${formatNumber(Math.round(subsPerMonth))}/mo ¬∑ ${formatNumber(subsNeeded)} to go</div>
                `;
            }
        }
    } catch (e) {
        document.getElementById('ytUpdated').textContent = 'Could not load YouTube data';
    }
}

function renderDashboard() {
    const data = loadMonthsData();
    const allMonths = data.months;

    // All-time totals
    let totalVideos = 0, totalLongform = 0, totalClips = 0, totalShorts = 0, totalThumbs = 0;
    allMonths.forEach(m => {
        m.videos.forEach(v => {
            totalVideos++;
            if (v.type === 'Longform') totalLongform++;
            else if (v.type === 'Clip') totalClips++;
            else if (v.type === 'Short') totalShorts++;
            if (v.thumbnailMade) totalThumbs++;
        });
    });

    document.getElementById('dashAlltimeStats').innerHTML = `
        <div class="dash-alltime-item"><div class="dash-alltime-num">${totalVideos}</div><div class="dash-alltime-lbl">Total Videos</div></div>
        <div class="dash-alltime-item"><div class="dash-alltime-num">${totalLongform}</div><div class="dash-alltime-lbl">Longform</div></div>
        <div class="dash-alltime-item"><div class="dash-alltime-num">${totalClips}</div><div class="dash-alltime-lbl">Clips</div></div>
        <div class="dash-alltime-item"><div class="dash-alltime-num">${totalShorts}</div><div class="dash-alltime-lbl">Shorts</div></div>
        <div class="dash-alltime-item"><div class="dash-alltime-num">${totalThumbs}</div><div class="dash-alltime-lbl">Thumbnails Made</div></div>
        <div class="dash-alltime-item"><div class="dash-alltime-num">${allMonths.length}</div><div class="dash-alltime-lbl">Months Tracked</div></div>
    `;

    // Monthly breakdown table
    let rows = '';
    allMonths.forEach(m => {
        const lf = m.videos.filter(v => v.type === 'Longform').length;
        const cl = m.videos.filter(v => v.type === 'Clip').length;
        const sh = m.videos.filter(v => v.type === 'Short').length;
        const th = m.videos.filter(v => v.thumbnailMade).length;
        rows += `<tr>
            <td>${m.label}</td>
            <td>${m.videos.length}</td>
            <td>${lf}</td>
            <td>${cl}</td>
            <td>${sh}</td>
            <td>${th}</td>
        </tr>`;
    });
    // Totals row
    rows += `<tr>
        <td>All Time</td>
        <td>${totalVideos}</td>
        <td>${totalLongform}</td>
        <td>${totalClips}</td>
        <td>${totalShorts}</td>
        <td>${totalThumbs}</td>
    </tr>`;

    document.getElementById('dashMonthsTable').innerHTML = `
        <table>
            <thead><tr><th>Month</th><th>Total</th><th>Longform</th><th>Clips</th><th>Shorts</th><th>Thumbnails</th></tr></thead>
            <tbody>${rows}</tbody>
        </table>
    `;

    fetchYouTubeStats();
}

// ---- Video Performance ----
const VP_CACHE_KEY = 'bigtech_vp_cache';
const VP_CACHE_TTL = 3600000; // 1 hour in ms

function parseDuration(iso) {
    // Parse ISO 8601 duration like PT1H25M30S ‚Üí total minutes
    if (!iso) return 0;
    const m = iso.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!m) return 0;
    return (parseInt(m[1] || 0) * 60) + parseInt(m[2] || 0) + (parseInt(m[3] || 0) / 60);
}

function formatDuration(mins) {
    const h = Math.floor(mins / 60);
    const m = Math.round(mins % 60);
    return h > 0 ? `${h}h ${m}m` : `${m}m`;
}

function getVpCache(ignoreExpiry) {
    try {
        const raw = localStorage.getItem(VP_CACHE_KEY);
        if (!raw) return null;
        const cache = JSON.parse(raw);
        if (!ignoreExpiry && Date.now() - cache.timestamp > VP_CACHE_TTL) return null; // stale
        return cache;
    } catch (e) { return null; }
}

function setVpCache(videos) {
    localStorage.setItem(VP_CACHE_KEY, JSON.stringify({ timestamp: Date.now(), videos }));
}

async function fetchVideoPerformance(maxItems) {
    const container = document.getElementById('vpContainer');
    container.innerHTML = '<div class="vp-loading"><div class="spinner"></div>Fetching video data from YouTube...</div>';

    try {
        // Step 1: Get video IDs from the uploads playlist
        // maxItems limits how many playlist items to fetch (saves API quota)
        const uploadsPlaylistId = YT_CHANNEL_ID.replace('UC', 'UU');
        let allVideoIds = [];
        let pageToken = '';

        do {
            const url = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId=${uploadsPlaylistId}&maxResults=50&key=${YT_API_KEY}` + (pageToken ? `&pageToken=${pageToken}` : '');
            const res = await fetch(url);
            if (!res.ok) throw new Error(`PlaylistItems API error: HTTP ${res.status}`);
            const data = await res.json();
            if (data.error) throw new Error(data.error.message);

            data.items.forEach(item => {
                allVideoIds.push(item.snippet.resourceId.videoId);
            });
            pageToken = data.nextPageToken || '';
            // Stop early if we have enough (saves quota)
            if (maxItems && allVideoIds.length >= maxItems) {
                allVideoIds = allVideoIds.slice(0, maxItems);
                pageToken = '';
            }
        } while (pageToken);

        console.log(`[VP] Found ${allVideoIds.length} total videos in uploads playlist`);

        // Step 2: Fetch video details in batches of 50
        let allVideos = [];
        for (let i = 0; i < allVideoIds.length; i += 50) {
            const batch = allVideoIds.slice(i, i + 50);
            const url = `https://www.googleapis.com/youtube/v3/videos?part=contentDetails,statistics,snippet&id=${batch.join(',')}&key=${YT_API_KEY}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error(`Videos API error: HTTP ${res.status}`);
            const data = await res.json();
            if (data.error) throw new Error(data.error.message);

            data.items.forEach(v => {
                const durationMins = parseDuration(v.contentDetails.duration);
                if (durationMins >= 35) {
                    allVideos.push({
                        id: v.id,
                        title: v.snippet.title,
                        publishedAt: v.snippet.publishedAt,
                        thumbnail: v.snippet.thumbnails?.maxres?.url || v.snippet.thumbnails?.high?.url || v.snippet.thumbnails?.medium?.url || v.snippet.thumbnails?.default?.url || '',
                        duration: durationMins,
                        views: parseInt(v.statistics.viewCount || '0')
                    });
                }
            });
        }

        console.log(`[VP] ${allVideos.length} videos are 35+ minutes`);

        // Sort reverse chronological
        allVideos.sort((a, b) => new Date(b.publishedAt) - new Date(a.publishedAt));

        // Cache the results
        setVpCache(allVideos);

        // Render from page 0
        vpCurrentPage = 0;
        renderVpList(allVideos, 0);

    } catch (err) {
        console.error('[VP] Fetch error:', err);
        container.innerHTML = `<div class="vp-loading" style="color:var(--red);">‚ùå Failed to load video data: ${err.message}</div>`;
        throw err; // Re-throw so callers (like Thumbnail Performance) can catch it
    }
}

const VP_PAGE_SIZE = 15;
let vpCurrentPage = 0;
let vpAllVideos = [];

function generateVpInsights(videos) {
    if (!videos || videos.length < 3) return [];
    const insights = [];

    const totalViews = videos.reduce((s, v) => s + v.views, 0);
    const avgViews = totalViews / videos.length;

    // Insight 1: Recent performance trend (last 5 vs overall)
    const recent = videos.slice(0, Math.min(5, videos.length));
    const recentAvg = recent.reduce((s, v) => s + v.views, 0) / recent.length;
    const recentPct = Math.round(((recentAvg - avgViews) / avgViews) * 100);
    if (recentPct > 10) {
        insights.push(`Your last ${recent.length} videos are trending ${recentPct}% above your channel average ‚Äî momentum is building.`);
    } else if (recentPct < -10) {
        insights.push(`Your last ${recent.length} videos are trending ${Math.abs(recentPct)}% below your channel average ‚Äî recent uploads are underperforming.`);
    } else {
        insights.push(`Your last ${recent.length} videos are performing right at your channel average ‚Äî steady and consistent.`);
    }

    // Insight 2: Best performing topic/video recently
    const recentTop = [...recent].sort((a, b) => b.views - a.views)[0];
    if (recentTop) {
        const multiplier = (recentTop.views / avgViews).toFixed(1);
        insights.push(`"${recentTop.title.substring(0, 60)}${recentTop.title.length > 60 ? '...' : ''}" is your top recent performer at ${formatNumber(recentTop.views)} views (${multiplier}x average).`);
    }

    // Insight 3: Duration sweet spot analysis
    const shortLong = videos.filter(v => v.duration >= 35 && v.duration <= 50);
    const medLong = videos.filter(v => v.duration > 50 && v.duration <= 75);
    const extraLong = videos.filter(v => v.duration > 75);
    const buckets = [
        { label: '35‚Äì50 min', vids: shortLong },
        { label: '50‚Äì75 min', vids: medLong },
        { label: '75+ min', vids: extraLong }
    ].filter(b => b.vids.length >= 2);

    if (buckets.length >= 2) {
        const bucketAvgs = buckets.map(b => ({
            label: b.label,
            avg: b.vids.reduce((s, v) => s + v.views, 0) / b.vids.length,
            count: b.vids.length
        }));
        const best = bucketAvgs.sort((a, b) => b.avg - a.avg)[0];
        insights.push(`Videos in the ${best.label} range perform best, averaging ${formatNumber(Math.round(best.avg))} views across ${best.count} videos.`);
    } else {
        // Fallback: green vs red count
        const aboveThreshold = avgViews * 1.2;
        const greenCount = videos.filter(v => v.views >= aboveThreshold).length;
        const greenPct = Math.round((greenCount / videos.length) * 100);
        insights.push(`${greenCount} of ${videos.length} longform videos (${greenPct}%) are performing above average ‚Äî ${greenPct >= 30 ? 'a healthy hit rate' : 'room to improve'}.`);
    }

    return insights;
}

async function fetchAiInsights(videos) {
    if (!videos || videos.length < 3) return null;
    try {
        const totalViews = videos.reduce((s, v) => s + v.views, 0);
        const avgViews = Math.round(totalViews / videos.length);
        const recent5 = videos.slice(0, Math.min(5, videos.length));
        const recentAvg = Math.round(recent5.reduce((s, v) => s + v.views, 0) / recent5.length);

        const payload = {
            videos: videos.slice(0, 40).map(v => ({
                title: v.title,
                views: v.views,
                duration: Math.round(v.duration),
                date: new Date(v.publishedAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })
            })),
            stats: {
                totalVideos: videos.length,
                avgViews: formatNumber(avgViews),
                recentAvg: formatNumber(recentAvg),
                channelAvg: formatNumber(avgViews)
            }
        };

        const res = await fetch(NB_WORKER_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!res.ok) {
            console.warn('[VP] AI insights worker error:', res.status);
            return null;
        }

        const data = await res.json();
        if (data.insights && data.insights.length > 0) {
            return data.insights;
        }
        return null;
    } catch (e) {
        console.warn('[VP] AI insights failed:', e.message);
        return null;
    }
}

function renderVpList(videos, page) {
    const container = document.getElementById('vpContainer');
    vpAllVideos = videos;

    if (page === undefined) page = vpCurrentPage;
    vpCurrentPage = page;

    if (!videos || videos.length === 0) {
        container.innerHTML = '<div class="vp-loading">No videos over 35 minutes found.</div>';
        return;
    }

    // Compute average views
    const totalViews = videos.reduce((sum, v) => sum + v.views, 0);
    const avgViews = totalViews / videos.length;
    const aboveThreshold = avgViews * 1.2;
    const belowThreshold = avgViews * 0.8;

    function getColor(views) {
        if (views >= aboveThreshold) return 'green';
        if (views <= belowThreshold) return 'red';
        return 'yellow';
    }

    // Pagination
    const totalPages = Math.ceil(videos.length / VP_PAGE_SIZE);
    if (page >= totalPages) page = totalPages - 1;
    if (page < 0) page = 0;
    vpCurrentPage = page;
    const startIdx = page * VP_PAGE_SIZE;
    const pageVideos = videos.slice(startIdx, startIdx + VP_PAGE_SIZE);

    // Cache age
    const cache = getVpCache();
    const cacheAge = cache ? Math.round((Date.now() - cache.timestamp) / 60000) : 0;
    const updatedText = cacheAge < 1 ? 'Updated just now' : `Updated ${cacheAge} min ago`;

    // Insights
    const insights = generateVpInsights(videos);

    let html = `
        <div class="vp-header">
            <h2>üìä Video Performance (${videos.length} videos over 35 min)</h2>
            <div class="vp-meta">${updatedText} ¬∑ Refreshes hourly</div>
        </div>
    `;

    if (insights.length > 0) {
        html += `<div class="vp-insights" id="vpInsightsBox">
            <div class="vp-insights-title">üí° Insights <span id="vpInsightsStatus" style="font-size:11px;color:#8899aa;font-weight:normal;margin-left:8px;">‚è≥ Generating fresh AI insights...</span></div>
            <ul id="vpInsightsList">${insights.map(i => `<li>${i}</li>`).join('')}</ul>
        </div>`;
    }

    html += `
        <div class="vp-legend">
            <div class="vp-legend-item"><div class="vp-legend-dot green"></div> Above average</div>
            <div class="vp-legend-item"><div class="vp-legend-dot yellow"></div> About average</div>
            <div class="vp-legend-item"><div class="vp-legend-dot red"></div> Below average</div>
        </div>
        <div class="vp-avg-bar">Average: ${formatNumber(Math.round(avgViews))} views per video</div>
        <div class="vp-list">
    `;

    pageVideos.forEach(v => {
        const color = getColor(v.views);
        const date = new Date(v.publishedAt);
        const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

        html += `
            <div class="vp-item ${color}">
                <img class="vp-thumb" src="${v.thumbnail}" alt="" loading="lazy">
                <div class="vp-info">
                    <div class="vp-title" title="${esc(v.title)}">${esc(v.title)}</div>
                    <div class="vp-date">${dateStr} ¬∑ ${formatDuration(v.duration)}</div>
                </div>
                <div class="vp-views ${color}">${formatNumber(v.views)} views</div>
            </div>
        `;
    });

    html += '</div>';

    // Pagination nav
    if (totalPages > 1) {
        html += `
            <div class="vp-pagination">
                <button class="vp-page-btn" onclick="vpGoPage(${page - 1})" ${page === 0 ? 'disabled' : ''}>‚Äπ</button>
                <span class="vp-page-info">Page ${page + 1} of ${totalPages}</span>
                <button class="vp-page-btn" onclick="vpGoPage(${page + 1})" ${page >= totalPages - 1 ? 'disabled' : ''}>‚Ä∫</button>
            </div>
        `;
    }

    container.innerHTML = html;

    // Async: fetch AI-powered insights and replace hardcoded ones
    if (insights.length > 0 && page === 0) {
        fetchAiInsights(videos).then(aiInsights => {
            const listEl = document.getElementById('vpInsightsList');
            const statusEl = document.getElementById('vpInsightsStatus');
            if (aiInsights && aiInsights.length > 0 && listEl) {
                listEl.innerHTML = aiInsights.map(i => `<li>${i}</li>`).join('');
                if (statusEl) statusEl.textContent = '‚ú® AI-powered';
            } else {
                if (statusEl) statusEl.textContent = '';
            }
        });
    }
}

function vpGoPage(page) {
    renderVpList(vpAllVideos, page);
    // Scroll to top of tab content
    document.getElementById('vpContainer').scrollIntoView({ behavior: 'smooth', block: 'start' });
}

function renderVideoPerformance() {
    // 1. Show cached data instantly if available
    const cache = getVpCache();
    if (cache && cache.videos) {
        renderVpList(cache.videos, vpCurrentPage);
        // Background refresh ‚Äî fetch fresh data without blocking the UI
        refreshVpInBackground();
        return;
    }
    // 2. Stale cache ‚Äî show it, then refresh
    const staleCache = getVpCache(true);
    if (staleCache && staleCache.videos) {
        renderVpList(staleCache.videos, vpCurrentPage);
        refreshVpInBackground();
        return;
    }
    // 3. No cache at all ‚Äî full blocking fetch
    vpCurrentPage = 0;
    fetchVideoPerformance().catch(() => {});
}

function refreshVpInBackground() {
    fetchVideoPerformance().then(() => {
        // fetchVideoPerformance already updates vpAllVideos, cache, and renders
        // Also refresh the TP full cache since it depends on VP data
        if (document.getElementById('thumbperf')?.classList.contains('active')) {
            refreshTpInBackground();
        }
    }).catch(() => {}); // Silent fail
}

// ---- Thumbnail Performance ----
// Shares data with Video Performance tab ‚Äî no separate API calls needed.
// CTR data fetched from YouTube Analytics via Cloudflare Worker.

const TP_CTR_CACHE_KEY = 'bigtech_tp_ctr_cache';
const TP_CTR_CACHE_TTL = 3600000; // 1 hour
const TP_FULL_CACHE_KEY = 'bigtech_tp_full_cache';
const TP_FULL_CACHE_TTL = 3600000; // 1 hour

function getTpCtrCache() {
    try {
        const raw = localStorage.getItem(TP_CTR_CACHE_KEY);
        if (!raw) return null;
        const cached = JSON.parse(raw);
        if (Date.now() - cached.timestamp > TP_CTR_CACHE_TTL) return null;
        return cached.data;
    } catch { return null; }
}

function setTpCtrCache(data) {
    localStorage.setItem(TP_CTR_CACHE_KEY, JSON.stringify({ timestamp: Date.now(), data }));
}

function getTpFullCache(ignoreExpiry) {
    try {
        const raw = localStorage.getItem(TP_FULL_CACHE_KEY);
        if (!raw) return null;
        const cached = JSON.parse(raw);
        if (!ignoreExpiry && Date.now() - cached.timestamp > TP_FULL_CACHE_TTL) return null;
        return cached;
    } catch { return null; }
}

function setTpFullCache(sortedVideos, analyticsData, hasCtr, sortLabel) {
    localStorage.setItem(TP_FULL_CACHE_KEY, JSON.stringify({
        timestamp: Date.now(),
        sortedVideos, analyticsData, hasCtr, sortLabel,
    }));
}

async function fetchAnalyticsData(videoIds, skipCache) {
    // Check cache first
    if (!skipCache) {
        const cached = getTpCtrCache();
        if (cached) return cached;
    }

    const ids = videoIds.join(',');
    const resp = await fetch(NB_WORKER_URL + '/analytics?ids=' + encodeURIComponent(ids));
    if (!resp.ok) throw new Error('Analytics fetch failed');
    const data = await resp.json();
    if (data.error) throw new Error(data.error);
    const result = { analytics: data.analytics || {}, hasCtr: !!data.hasCtr };
    setTpCtrCache(result);
    return result;
}

function renderThumbnailPerformance() {
    // 1. Try full cached result that has analytics data ‚Äî instant render
    const fullCache = getTpFullCache();
    if (fullCache && fullCache.analyticsData && Object.keys(fullCache.analyticsData).length > 0) {
        renderTpGrid(null, fullCache);
        return;
    }
    // 2. Try stale full cache with analytics
    const staleFullCache = getTpFullCache(true);
    if (staleFullCache && staleFullCache.analyticsData && Object.keys(staleFullCache.analyticsData).length > 0) {
        renderTpGrid(null, staleFullCache);
        return;
    }
    // 3. No cache with analytics ‚Äî fetch from scratch (show spinner, get the real data)
    const container = document.getElementById('tpContainer');
    container.innerHTML = '<div class="vp-loading"><div class="spinner"></div>Fetching thumbnail performance data...</div>';
    loadTpFromScratch();
}

function loadTpFromScratch() {
    // Get video data
    let videos = null;
    if (vpAllVideos && vpAllVideos.length > 0) {
        videos = vpAllVideos.slice(0, 30);
    } else {
        const vpCache = getVpCache() || getVpCache(true);
        if (vpCache && vpCache.videos && vpCache.videos.length > 0) {
            videos = vpCache.videos.slice(0, 30);
        }
    }

    if (videos) {
        // We have video data ‚Äî go straight to fetching analytics
        fetchTpAnalyticsAndRender(videos);
    } else {
        // Need to fetch videos first
        const container = document.getElementById('tpContainer');
        container.innerHTML = '<div class="vp-loading"><div class="spinner"></div>Fetching video data from YouTube...</div>';
        fetchVideoPerformance(50).then(() => {
            if (vpAllVideos && vpAllVideos.length > 0) {
                fetchTpAnalyticsAndRender(vpAllVideos.slice(0, 30));
            }
        }).catch(() => {
            container.innerHTML = '<div class="vp-loading" style="color:var(--red);">‚ùå YouTube API quota exceeded. Try again later.</div>';
        });
    }
}

function fetchTpAnalyticsAndRender(videos) {
    const container = document.getElementById('tpContainer');
    container.innerHTML = '<div class="vp-loading"><div class="spinner"></div>Loading analytics data...</div>';

    const videoIds = videos.map(v => v.id);
    fetchAnalyticsData(videoIds, true).then(result => {
        const analyticsData = result.analytics || result;
        const hasCtr = !!result.hasCtr;

        if (!analyticsData || Object.keys(analyticsData).length === 0) {
            const sorted = [...videos].sort((a, b) => b.views - a.views);
            setTpFullCache(sorted, null, false, 'Sorted by views');
            renderTpGrid(null, { sortedVideos: sorted, analyticsData: null, hasCtr: false, sortLabel: 'Sorted by views' });
            return;
        }

        let sorted, sortLabel;
        if (hasCtr) {
            sorted = [...videos].sort((a, b) => {
                const aCtr = analyticsData[a.id]?.ctr ?? -1;
                const bCtr = analyticsData[b.id]?.ctr ?? -1;
                return bCtr - aCtr;
            });
            sortLabel = '‚ú® Ranked by CTR';
        } else {
            sorted = [...videos].sort((a, b) => getViewsPerDay(b) - getViewsPerDay(a));
            sortLabel = 'Ranked by performance';
        }

        setTpFullCache(sorted, analyticsData, hasCtr, sortLabel);
        renderTpGrid(null, { sortedVideos: sorted, analyticsData, hasCtr, sortLabel });
    }).catch(err => {
        console.warn('[TP] Analytics fetch failed:', err.message);
        const sorted = [...videos].sort((a, b) => b.views - a.views);
        setTpFullCache(sorted, null, false, 'Sorted by views');
        renderTpGrid(null, { sortedVideos: sorted, analyticsData: null, hasCtr: false, sortLabel: 'Sorted by views' });
    });
}

function refreshTpInBackground() {
    // Step 1: Re-fetch video list (also refreshes VP cache)
    fetchVideoPerformance(50).then(() => {
        const videos = vpAllVideos && vpAllVideos.length > 0 ? vpAllVideos.slice(0, 30) : null;
        if (!videos) return;

        // Step 2: Fetch fresh analytics (bypass CTR cache)
        const ids = videos.map(v => v.id).join(',');
        return fetch(NB_WORKER_URL + '/analytics?ids=' + encodeURIComponent(ids)).then(resp => {
            if (!resp.ok) return;
            return resp.json();
        }).then(data => {
            if (!data || data.error) return;
            const result = { analytics: data.analytics || {}, hasCtr: !!data.hasCtr };
            setTpCtrCache(result);

            const analyticsData = result.analytics;
            const hasCtr = result.hasCtr;
            if (!analyticsData || Object.keys(analyticsData).length === 0) return;

            let sorted, sortLabel;
            if (hasCtr) {
                sorted = [...videos].sort((a, b) => (analyticsData[b.id]?.ctr ?? -1) - (analyticsData[a.id]?.ctr ?? -1));
                sortLabel = '‚ú® Ranked by CTR';
            } else {
                sorted = [...videos].sort((a, b) => getViewsPerDay(b) - getViewsPerDay(a));
                sortLabel = 'Ranked by performance';
            }

            setTpFullCache(sorted, analyticsData, hasCtr, sortLabel);

            // Only update UI if thumbnail perf tab is still active
            if (document.getElementById('thumbperf')?.classList.contains('active')) {
                renderTpGrid(null, { sortedVideos: sorted, analyticsData, hasCtr, sortLabel });
            }
        });
    }).catch(() => {}); // Silent fail for background refresh
}

function getViewsPerDay(video) {
    const days = Math.max(1, (Date.now() - new Date(video.publishedAt).getTime()) / (1000 * 60 * 60 * 24));
    return video.views / days;
}

function renderTpGrid(unused, cachedResult) {
    const container = document.getElementById('tpContainer');
    const { sortedVideos, analyticsData, hasCtr, sortLabel } = cachedResult;

    if (!sortedVideos || sortedVideos.length === 0) {
        container.innerHTML = '<div class="vp-loading">No videos found.</div>';
        return;
    }

    const hasAnalytics = analyticsData && Object.keys(analyticsData).length > 0;

    // Cache age
    const fullCache = getTpFullCache(true);
    const cacheAge = fullCache ? Math.round((Date.now() - fullCache.timestamp) / 60000) : 0;
    const updatedText = cacheAge < 1 ? 'Updated just now' : `Updated ${cacheAge} min ago`;

    function buildTierHtml(videos, tier, tierLabel, rankOffset) {
        let rangeText;
        if (hasCtr) {
            const ctrs = videos.map(v => analyticsData[v.id]?.ctr).filter(x => x != null && x > 0);
            rangeText = ctrs.length > 0
                ? `${(Math.min(...ctrs) * 100).toFixed(1)}% ‚Äì ${(Math.max(...ctrs) * 100).toFixed(1)}% CTR`
                : '';
        } else {
            rangeText = videos.length > 0
                ? `${formatNumber(videos[videos.length - 1].views)} ‚Äì ${formatNumber(videos[0].views)} views`
                : '';
        }

        let html = `<div class="tp-tier">
            <div class="tp-tier-header">
                <span class="tp-tier-badge ${tier}">${tierLabel}</span>
                <span class="tp-tier-label">${tier === 'top' ? 'Highest Performing' : tier === 'mid' ? 'Middle of the Pack' : 'Lowest Performing'}</span>
                <span class="tp-tier-range">${rangeText}</span>
            </div>
            <div class="tp-grid">`;

        videos.forEach((v, i) => {
            const date = new Date(v.publishedAt);
            const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            const thumbUrl = v.thumbnail || '';
            const aData = hasAnalytics && analyticsData[v.id];
            const ctrPct = aData?.ctr != null ? (aData.ctr * 100).toFixed(1) : null;
            const avgPct = aData?.avgViewPct;
            const retText = avgPct != null ? `${avgPct.toFixed(1)}% retention` : '';
            const ctrText = ctrPct != null ? `${ctrPct}% CTR` : '';
            const impressionsText = aData?.impressions ? `${formatNumber(aData.impressions)} impr.` : '';

            html += `
                <div class="tp-card ${tier}">
                    <div class="tp-rank">#${rankOffset + i + 1}</div>
                    <img class="tp-card-img" src="${thumbUrl}" alt="" loading="lazy">
                    <div class="tp-card-body">
                        <div class="tp-card-title" title="${esc(v.title)}">${esc(v.title)}</div>
                        <div class="tp-card-stats">
                            ${ctrText ? `<span class="tp-card-views ${tier}" style="font-weight:700;">${ctrText}</span>` : ''}
                            ${impressionsText ? `<span class="tp-card-date">${impressionsText}</span>` : ''}
                            <span class="tp-card-views ${!ctrText ? tier : ''}">${formatNumber(v.views)} views</span>
                            ${retText ? `<span class="tp-card-date">${retText}</span>` : ''}
                            <span class="tp-card-date">${dateStr}</span>
                        </div>
                    </div>
                </div>`;
        });

        html += '</div></div>';
        return html;
    }

    const top10 = sortedVideos.slice(0, 10);
    const mid10 = sortedVideos.slice(10, 20);
    const bottom10 = sortedVideos.slice(20, 30);

    let html = `
        <div class="tp-header">
            <h2>üñºÔ∏è Thumbnail Performance (Last 30 Videos)</h2>
            <div class="tp-meta">${updatedText} ¬∑ ${sortLabel}</div>
        </div>
    `;

    html += buildTierHtml(top10, 'top', 'Top 10', 0);
    html += buildTierHtml(mid10, 'mid', 'Middle 10', 10);
    html += buildTierHtml(bottom10, 'bottom', 'Bottom 10', 20);

    container.innerHTML = html;
}

// ---- Subscriber Growth ----
const SG_CACHE_KEY = 'bigtech_sg_cache';
const SG_CACHE_TTL = 6 * 60 * 60 * 1000; // 6 hours

let sgData = null;
let sgDays = 90;

function getSgCache() {
    try {
        const raw = localStorage.getItem(SG_CACHE_KEY);
        if (!raw) return null;
        const cached = JSON.parse(raw);
        if (Date.now() - cached.timestamp > SG_CACHE_TTL) return null;
        return cached;
    } catch { return null; }
}

function setSgCache(data) {
    localStorage.setItem(SG_CACHE_KEY, JSON.stringify({ timestamp: Date.now(), data }));
}

async function fetchSubGrowth(days) {
    const container = document.getElementById('sgContainer');

    // Check cache
    const cached = getSgCache();
    if (cached && cached.data && cached.data.length > 0) {
        sgData = cached.data;
        renderSgContent(sgData, days);
        return;
    }

    container.innerHTML = '<div class="vp-loading"><div class="spinner"></div>Fetching subscriber growth data...</div>';

    try {
        const resp = await fetch(NB_WORKER_URL + '/sub-growth?days=' + days);
        if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
        const result = await resp.json();
        if (result.error) throw new Error(result.error);

        sgData = result.data || [];
        setSgCache(sgData);
        renderSgContent(sgData, days);
    } catch (err) {
        console.error('[SG] Error:', err);
        container.innerHTML = `<div class="vp-loading" style="color:var(--red);">‚ùå Failed to load subscriber data: ${err.message}</div>`;
    }
}

function renderSgContent(data, days) {
    const container = document.getElementById('sgContainer');
    if (!data || data.length === 0) {
        container.innerHTML = '<div class="vp-loading">No subscriber growth data available.</div>';
        return;
    }

    // Slice to requested days
    const sliced = data.slice(-days);

    // Compute stats
    const totalGained = sliced.reduce((s, d) => s + d.gained, 0);
    const totalLost = sliced.reduce((s, d) => s + d.lost, 0);
    const totalNet = sliced.reduce((s, d) => s + d.net, 0);
    const avgPerDay = totalNet / sliced.length;
    const bestDay = sliced.reduce((best, d) => d.net > best.net ? d : best, sliced[0]);
    const worstDay = sliced.reduce((worst, d) => d.net < worst.net ? d : worst, sliced[0]);

    // Cache age
    const cache = getSgCache();
    const cacheAge = cache ? Math.round((Date.now() - cache.timestamp) / 60000) : 0;
    const updatedText = cacheAge < 1 ? 'Updated just now' : `Updated ${cacheAge} min ago`;

    let html = `
        <div class="sg-header">
            <h2>üìà Subscriber Growth</h2>
            <div style="display:flex; align-items:center; gap:12px;">
                <div class="sg-meta">${updatedText}</div>
                <div class="sg-controls">
                    <select id="sgDaysSelect" onchange="changeSgDays(this.value)">
                        <option value="30" ${days === 30 ? 'selected' : ''}>Last 30 Days</option>
                        <option value="60" ${days === 60 ? 'selected' : ''}>Last 60 Days</option>
                        <option value="90" ${days === 90 ? 'selected' : ''}>Last 90 Days</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="sg-stats">
            <div class="sg-stat">
                <div class="sg-stat-num ${totalNet >= 0 ? 'positive' : 'negative'}">${totalNet >= 0 ? '+' : ''}${totalNet.toLocaleString()}</div>
                <div class="sg-stat-label">Net Subscribers</div>
            </div>
            <div class="sg-stat">
                <div class="sg-stat-num positive">+${totalGained.toLocaleString()}</div>
                <div class="sg-stat-label">Gained</div>
            </div>
            <div class="sg-stat">
                <div class="sg-stat-num negative">-${totalLost.toLocaleString()}</div>
                <div class="sg-stat-label">Lost</div>
            </div>
            <div class="sg-stat">
                <div class="sg-stat-num ${avgPerDay >= 0 ? 'positive' : 'negative'}">${avgPerDay >= 0 ? '+' : ''}${avgPerDay.toFixed(1)}</div>
                <div class="sg-stat-label">Avg/Day</div>
            </div>
        </div>
    `;

    // Build SVG chart
    html += buildSgChart(sliced);

    // Daily table
    html += buildSgTable(sliced, bestDay, worstDay);

    container.innerHTML = html;
}

function buildSgChart(data) {
    const width = Math.max(700, data.length * 12);
    const height = 280;
    const padLeft = 50, padRight = 20, padTop = 20, padBottom = 40;
    const chartW = width - padLeft - padRight;
    const chartH = height - padTop - padBottom;

    // Build cumulative net data
    let cumulative = [];
    let running = 0;
    for (const d of data) {
        running += d.net;
        cumulative.push(running);
    }

    const minVal = Math.min(0, ...cumulative);
    const maxVal = Math.max(0, ...cumulative);
    const range = maxVal - minVal || 1;

    function x(i) { return padLeft + (i / (data.length - 1)) * chartW; }
    function y(val) { return padTop + chartH - ((val - minVal) / range) * chartH; }

    // Build path
    const points = cumulative.map((val, i) => `${x(i).toFixed(1)},${y(val).toFixed(1)}`);
    const linePath = 'M' + points.join(' L');

    // Area fill
    const areaPath = linePath + ` L${x(data.length - 1).toFixed(1)},${y(0).toFixed(1)} L${x(0).toFixed(1)},${y(0).toFixed(1)} Z`;

    // Y-axis labels (5 ticks)
    const yTicks = 5;
    let yLabels = '';
    let gridLines = '';
    for (let i = 0; i <= yTicks; i++) {
        const val = minVal + (range * i / yTicks);
        const yPos = y(val);
        yLabels += `<text x="${padLeft - 8}" y="${yPos + 4}" text-anchor="end" fill="#8899aa" font-size="10">${val >= 0 ? '+' : ''}${Math.round(val)}</text>`;
        gridLines += `<line x1="${padLeft}" y1="${yPos}" x2="${width - padRight}" y2="${yPos}" stroke="#e8ecf1" stroke-dasharray="3,3"/>`;
    }

    // X-axis date labels (show ~6-8 labels)
    let xLabels = '';
    const labelInterval = Math.max(1, Math.floor(data.length / 7));
    for (let i = 0; i < data.length; i += labelInterval) {
        const d = new Date(data[i].date);
        const label = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        xLabels += `<text x="${x(i)}" y="${height - 6}" text-anchor="middle" fill="#8899aa" font-size="10">${label}</text>`;
    }
    // Always show last date
    if (data.length > 1) {
        const lastD = new Date(data[data.length - 1].date);
        const lastLabel = lastD.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        xLabels += `<text x="${x(data.length - 1)}" y="${height - 6}" text-anchor="end" fill="#8899aa" font-size="10">${lastLabel}</text>`;
    }

    // Zero line
    const zeroY = y(0);
    const zeroLine = `<line x1="${padLeft}" y1="${zeroY}" x2="${width - padRight}" y2="${zeroY}" stroke="#8899aa" stroke-width="1"/>`;

    // Determine gradient colors based on final value
    const finalPositive = cumulative[cumulative.length - 1] >= 0;
    const lineColor = finalPositive ? '#22c55e' : '#ef4444';
    const fillColor = finalPositive ? 'rgba(34,197,94,0.12)' : 'rgba(239,68,68,0.12)';

    const svg = `
        <div class="sg-chart-wrap">
            <div class="sg-chart-title">Cumulative Net Subscriber Growth</div>
            <div class="sg-chart">
                <svg width="100%" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMinYMin meet">
                    ${gridLines}
                    ${zeroLine}
                    <path d="${areaPath}" fill="${fillColor}"/>
                    <path d="${linePath}" fill="none" stroke="${lineColor}" stroke-width="2.5" stroke-linejoin="round"/>
                    ${yLabels}
                    ${xLabels}
                </svg>
            </div>
        </div>
    `;

    // Also build a daily bar chart showing net per day
    const maxNet = Math.max(...data.map(d => Math.abs(d.net)), 1);
    const barH = 200;
    const barChartW = Math.max(700, data.length * 12);
    const barPadTop = 20, barPadBottom = 40;
    const barAreaH = barH - barPadTop - barPadBottom;
    const barMid = barPadTop + barAreaH / 2;
    const barW = Math.max(2, (chartW / data.length) - 2);

    let bars = '';
    for (let i = 0; i < data.length; i++) {
        const bx = padLeft + (i / data.length) * chartW;
        const net = data[i].net;
        const barHeight = (Math.abs(net) / maxNet) * (barAreaH / 2);
        const color = net >= 0 ? '#22c55e' : '#ef4444';
        if (net >= 0) {
            bars += `<rect x="${bx}" y="${barMid - barHeight}" width="${barW}" height="${barHeight}" fill="${color}" rx="1" opacity="0.8"/>`;
        } else {
            bars += `<rect x="${bx}" y="${barMid}" width="${barW}" height="${barHeight}" fill="${color}" rx="1" opacity="0.8"/>`;
        }
    }

    // Bar chart y-axis
    let barYLabels = '';
    barYLabels += `<text x="${padLeft - 8}" y="${barPadTop + 4}" text-anchor="end" fill="#8899aa" font-size="10">+${maxNet}</text>`;
    barYLabels += `<text x="${padLeft - 8}" y="${barMid + 4}" text-anchor="end" fill="#8899aa" font-size="10">0</text>`;
    barYLabels += `<text x="${padLeft - 8}" y="${barPadTop + barAreaH + 4}" text-anchor="end" fill="#8899aa" font-size="10">-${maxNet}</text>`;
    const barZeroLine = `<line x1="${padLeft}" y1="${barMid}" x2="${barChartW - padRight}" y2="${barMid}" stroke="#8899aa" stroke-width="1"/>`;

    // Bar chart x-axis labels
    let barXLabels = '';
    for (let i = 0; i < data.length; i += labelInterval) {
        const bx = padLeft + (i / data.length) * chartW;
        const d = new Date(data[i].date);
        const label = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        barXLabels += `<text x="${bx}" y="${barH - 6}" text-anchor="middle" fill="#8899aa" font-size="10">${label}</text>`;
    }

    const barSvg = `
        <div class="sg-chart-wrap">
            <div class="sg-chart-title">Daily Net Subscribers</div>
            <div class="sg-chart">
                <svg width="100%" viewBox="0 0 ${barChartW} ${barH}" preserveAspectRatio="xMinYMin meet">
                    ${barZeroLine}
                    ${bars}
                    ${barYLabels}
                    ${barXLabels}
                </svg>
            </div>
        </div>
    `;

    return svg + barSvg;
}

function buildSgTable(data, bestDay, worstDay) {
    const reversed = [...data].reverse(); // Most recent first
    const maxGained = Math.max(...data.map(d => d.gained), 1);

    let rows = reversed.map(d => {
        const date = new Date(d.date);
        const dateStr = date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
        const netClass = d.net >= 0 ? 'sg-net-pos' : 'sg-net-neg';
        const netStr = (d.net >= 0 ? '+' : '') + d.net;
        const gainedBarW = Math.round((d.gained / maxGained) * 80);
        const lostBarW = Math.round((d.lost / maxGained) * 80);
        const isBest = d.date === bestDay.date;
        const isWorst = d.date === worstDay.date;
        const badge = isBest ? ' <span style="font-size:10px; background:#dcfce7; color:#15803d; padding:2px 6px; border-radius:8px; font-weight:600;">BEST</span>'
                     : isWorst ? ' <span style="font-size:10px; background:#fee2e2; color:#b91c1c; padding:2px 6px; border-radius:8px; font-weight:600;">WORST</span>'
                     : '';

        return `<tr>
            <td>${dateStr}${badge}</td>
            <td>+${d.gained} <span class="sg-bar gained" style="width:${gainedBarW}px;"></span></td>
            <td>-${d.lost} <span class="sg-bar lost" style="width:${lostBarW}px;"></span></td>
            <td class="${netClass}">${netStr}</td>
        </tr>`;
    }).join('');

    return `
        <div class="sg-table-wrap">
            <div class="sg-table-title">Daily Breakdown</div>
            <table class="sg-table">
                <thead><tr>
                    <th>Date</th>
                    <th>Gained</th>
                    <th>Lost</th>
                    <th>Net</th>
                </tr></thead>
                <tbody>${rows}</tbody>
            </table>
        </div>
    `;
}

function changeSgDays(val) {
    sgDays = parseInt(val);
    if (sgData && sgData.length > 0) {
        renderSgContent(sgData, sgDays);
    } else {
        fetchSubGrowth(sgDays);
    }
}

function renderSubGrowth() {
    if (sgData && sgData.length > 0) {
        renderSgContent(sgData, sgDays);
        return;
    }
    fetchSubGrowth(sgDays);
}

// ---- Podcast Analytics ----
const POD_CACHE_KEY = 'bigtech_pod_cache';
const POD_CACHE_TTL = 6 * 60 * 60 * 1000; // 6 hours
let podData = null;
let podTimeRange = 'all';

function getPodCache() {
    try {
        const raw = localStorage.getItem(POD_CACHE_KEY);
        if (!raw) return null;
        const cached = JSON.parse(raw);
        if (Date.now() - cached.timestamp > POD_CACHE_TTL) return null;
        return cached;
    } catch { return null; }
}

function setPodCache(episodes) {
    localStorage.setItem(POD_CACHE_KEY, JSON.stringify({ timestamp: Date.now(), episodes }));
}

async function fetchPodcastData() {
    const container = document.getElementById('podContainer');

    const cached = getPodCache();
    if (cached && cached.episodes && cached.episodes.length > 0) {
        podData = cached.episodes;
        renderPodContent(podData, podTimeRange);
        return;
    }

    container.innerHTML = '<div class="vp-loading"><div class="spinner"></div>Loading podcast analytics...</div>';

    try {
        const resp = await fetch(NB_WORKER_URL + '/podcast');
        if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
        const result = await resp.json();
        if (result.error) throw new Error(result.error);

        podData = result.episodes || [];
        setPodCache(podData);
        renderPodContent(podData, podTimeRange);
    } catch (err) {
        console.error('[Pod] Error:', err);
        container.innerHTML = `<div class="vp-loading" style="color:var(--red);">‚ùå Failed to load podcast data: ${err.message}</div>`;
    }
}

function filterPodByRange(episodes, range) {
    if (range === 'all') return episodes;
    const now = new Date();
    let cutoff;
    if (range === '2026') cutoff = new Date('2026-01-01');
    else if (range === '2025') cutoff = new Date('2025-01-01');
    else if (range === '2024') cutoff = new Date('2024-01-01');
    else if (range === '12m') cutoff = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
    else if (range === '6m') cutoff = new Date(now.getTime() - 182 * 24 * 60 * 60 * 1000);
    else if (range === '3m') cutoff = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
    else return episodes;

    const endCutoff = (range === '2025') ? new Date('2026-01-01') : (range === '2024') ? new Date('2025-01-01') : null;

    return episodes.filter(ep => {
        const d = new Date(ep.published);
        if (d < cutoff) return false;
        if (endCutoff && d >= endCutoff) return false;
        return true;
    });
}

function renderPodContent(allEpisodes, range) {
    const container = document.getElementById('podContainer');
    const episodes = filterPodByRange(allEpisodes, range);

    if (!episodes || episodes.length === 0) {
        container.innerHTML = '<div class="vp-loading">No podcast episodes found for this period.</div>';
        return;
    }

    const totalDownloads = episodes.reduce((s, e) => s + e.total, 0);
    const avgPerEpisode = Math.round(totalDownloads / episodes.length);
    const totalStreams = episodes.reduce((s, e) => s + e.streams, 0);
    const totalDls = episodes.reduce((s, e) => s + e.downloads, 0);
    const streamPct = totalDownloads > 0 ? Math.round((totalStreams / totalDownloads) * 100) : 0;

    // Recent trend: last 10 vs previous 10
    const recent10 = episodes.slice(0, Math.min(10, episodes.length));
    const prev10 = episodes.slice(10, Math.min(20, episodes.length));
    const recentAvg = recent10.reduce((s, e) => s + e.total, 0) / recent10.length;
    const prevAvg = prev10.length > 0 ? prev10.reduce((s, e) => s + e.total, 0) / prev10.length : recentAvg;
    const trendPct = prevAvg > 0 ? Math.round(((recentAvg - prevAvg) / prevAvg) * 100) : 0;

    const rangeLabel = range === 'all' ? 'All Time' : range === '12m' ? 'Last 12 Months' : range === '6m' ? 'Last 6 Months' : range === '3m' ? 'Last 3 Months' : range;

    let html = `
        <div class="pod-header">
            <h2>üéôÔ∏è Podcast Analytics (${episodes.length} episodes)</h2>
            <div style="display:flex;align-items:center;gap:12px;">
                <div class="pod-meta">${rangeLabel} ¬∑ ${formatNumber(totalDownloads)} total listens</div>
                <div class="pod-controls">
                    <select id="podRange" onchange="changePodRange(this.value)">
                        <option value="all" ${range==='all'?'selected':''}>All Time</option>
                        <option value="2026" ${range==='2026'?'selected':''}>2026</option>
                        <option value="2025" ${range==='2025'?'selected':''}>2025</option>
                        <option value="2024" ${range==='2024'?'selected':''}>2024</option>
                        <option value="12m" ${range==='12m'?'selected':''}>Last 12 Months</option>
                        <option value="6m" ${range==='6m'?'selected':''}>Last 6 Months</option>
                        <option value="3m" ${range==='3m'?'selected':''}>Last 3 Months</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="pod-stats">
            <div class="pod-stat">
                <div class="pod-stat-num">${formatNumber(totalDownloads)}</div>
                <div class="pod-stat-label">Total Listens</div>
            </div>
            <div class="pod-stat">
                <div class="pod-stat-num">${formatNumber(avgPerEpisode)}</div>
                <div class="pod-stat-label">Avg Per Episode</div>
            </div>
            <div class="pod-stat">
                <div class="pod-stat-num">${streamPct}%</div>
                <div class="pod-stat-label">Streaming</div>
            </div>
            <div class="pod-stat">
                <div class="pod-stat-num ${trendPct >= 0 ? 'pod-trend-up' : 'pod-trend-down'}">${trendPct >= 0 ? '+' : ''}${trendPct}%</div>
                <div class="pod-stat-label">Recent Trend</div>
            </div>
        </div>
    `;

    // Episode performance chart (last 50 episodes, bar chart)
    html += buildPodChart(episodes);

    // Top 15 episodes
    html += buildPodTopList(episodes);

    // Recent episodes list
    html += buildPodRecentList(episodes);

    container.innerHTML = html;
}

function buildPodChart(episodes) {
    // Show up to last 50 episodes chronologically
    const chrono = [...episodes].reverse().slice(-50);
    const maxTotal = Math.max(...chrono.map(e => e.total), 1);

    const width = Math.max(700, chrono.length * 16);
    const height = 260;
    const padLeft = 55, padRight = 20, padTop = 20, padBottom = 50;
    const chartW = width - padLeft - padRight;
    const chartH = height - padTop - padBottom;
    const barW = Math.max(4, (chartW / chrono.length) - 3);

    const avg = chrono.reduce((s, e) => s + e.total, 0) / chrono.length;

    let bars = '';
    let xLabels = '';
    const labelInterval = Math.max(1, Math.floor(chrono.length / 8));

    chrono.forEach((ep, i) => {
        const bx = padLeft + (i / chrono.length) * chartW;
        const barH = (ep.total / maxTotal) * chartH;
        const streamH = ep.streams > 0 ? (ep.streams / maxTotal) * chartH : 0;
        const dlH = barH - streamH;

        // Downloads portion (bottom)
        bars += `<rect x="${bx}" y="${padTop + chartH - barH}" width="${barW}" height="${dlH}" fill="#4a90d9" rx="1" opacity="0.85"/>`;
        // Streams portion (top)
        if (streamH > 0) {
            bars += `<rect x="${bx}" y="${padTop + chartH - streamH}" width="${barW}" height="${streamH}" fill="#c9953c" rx="1" opacity="0.85"/>`;
        }

        if (i % labelInterval === 0) {
            const d = new Date(ep.published);
            const label = d.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
            xLabels += `<text x="${bx + barW/2}" y="${height - 8}" text-anchor="middle" fill="#8899aa" font-size="9" transform="rotate(-35,${bx + barW/2},${height - 8})">${label}</text>`;
        }
    });

    // Average line
    const avgY = padTop + chartH - (avg / maxTotal) * chartH;
    const avgLine = `<line x1="${padLeft}" y1="${avgY}" x2="${width - padRight}" y2="${avgY}" stroke="#c9953c" stroke-width="1.5" stroke-dasharray="6,4"/>`;
    const avgLabel = `<text x="${width - padRight + 4}" y="${avgY + 4}" fill="#c9953c" font-size="10" font-weight="600">${formatNumber(Math.round(avg))}</text>`;

    // Y-axis
    let yLabels = '';
    for (let i = 0; i <= 4; i++) {
        const val = (maxTotal * i / 4);
        const yPos = padTop + chartH - (i / 4) * chartH;
        yLabels += `<text x="${padLeft - 8}" y="${yPos + 4}" text-anchor="end" fill="#8899aa" font-size="10">${formatNumber(Math.round(val))}</text>`;
    }

    // Legend
    const legend = `
        <rect x="${padLeft}" y="${height - 18}" width="10" height="10" fill="#4a90d9" rx="2"/>
        <text x="${padLeft + 14}" y="${height - 9}" fill="#8899aa" font-size="10">Downloads</text>
        <rect x="${padLeft + 85}" y="${height - 18}" width="10" height="10" fill="#c9953c" rx="2"/>
        <text x="${padLeft + 99}" y="${height - 9}" fill="#8899aa" font-size="10">Streams</text>
    `;

    return `
        <div class="pod-chart-wrap">
            <div class="pod-chart-title">Episode Performance Over Time</div>
            <div class="pod-chart">
                <svg width="100%" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMinYMin meet">
                    ${bars}
                    ${avgLine}
                    ${avgLabel}
                    ${yLabels}
                    ${xLabels}
                </svg>
            </div>
        </div>
    `;
}

function buildPodTopList(episodes) {
    const sorted = [...episodes].sort((a, b) => b.total - a.total);
    const top15 = sorted.slice(0, 15);
    const maxTotal = top15[0]?.total || 1;

    let items = top15.map((ep, i) => {
        const d = new Date(ep.published);
        const dateStr = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        const barPct = Math.round((ep.total / maxTotal) * 100);
        return `
            <div class="pod-ep">
                <div class="pod-ep-rank">${i + 1}</div>
                <div class="pod-ep-info">
                    <div class="pod-ep-title" title="${esc(ep.title)}">${esc(ep.title)}</div>
                    <div class="pod-ep-date">${dateStr}</div>
                </div>
                <div class="pod-ep-bar-wrap"><div class="pod-ep-bar" style="width:${barPct}%"></div></div>
                <div class="pod-ep-stats">
                    <div class="pod-ep-total">${formatNumber(ep.total)}</div>
                    <div class="pod-ep-breakdown">${formatNumber(ep.downloads)} dl ¬∑ ${formatNumber(ep.streams)} str</div>
                </div>
            </div>
        `;
    }).join('');

    return `
        <div class="pod-top-list">
            <div class="pod-top-title">üèÜ Top 15 Episodes</div>
            ${items}
        </div>
    `;
}

function buildPodRecentList(episodes) {
    const recent20 = episodes.slice(0, 20);
    const avg = episodes.reduce((s, e) => s + e.total, 0) / episodes.length;
    const maxTotal = Math.max(...recent20.map(e => e.total), 1);

    let items = recent20.map((ep, i) => {
        const d = new Date(ep.published);
        const dateStr = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        const barPct = Math.round((ep.total / maxTotal) * 100);
        const vsAvg = Math.round(((ep.total - avg) / avg) * 100);
        const trendClass = vsAvg >= 0 ? 'pod-trend-up' : 'pod-trend-down';
        const trendStr = (vsAvg >= 0 ? '+' : '') + vsAvg + '% vs avg';
        return `
            <div class="pod-ep">
                <div class="pod-ep-rank" style="background:${ep.total >= avg * 1.2 ? 'var(--green)' : ep.total <= avg * 0.8 ? 'var(--red)' : 'var(--navy)'}">${i + 1}</div>
                <div class="pod-ep-info">
                    <div class="pod-ep-title" title="${esc(ep.title)}">${esc(ep.title)}</div>
                    <div class="pod-ep-date">${dateStr} ¬∑ <span class="${trendClass}">${trendStr}</span></div>
                </div>
                <div class="pod-ep-bar-wrap"><div class="pod-ep-bar" style="width:${barPct}%"></div></div>
                <div class="pod-ep-stats">
                    <div class="pod-ep-total">${formatNumber(ep.total)}</div>
                    <div class="pod-ep-breakdown">${formatNumber(ep.downloads)} dl ¬∑ ${formatNumber(ep.streams)} str</div>
                </div>
            </div>
        `;
    }).join('');

    return `
        <div class="pod-top-list">
            <div class="pod-top-title">üìÖ Recent Episodes</div>
            ${items}
        </div>
    `;
}

function changePodRange(val) {
    podTimeRange = val;
    if (podData && podData.length > 0) {
        renderPodContent(podData, podTimeRange);
    }
}

function renderPodcast() {
    if (podData && podData.length > 0) {
        renderPodContent(podData, podTimeRange);
        return;
    }
    fetchPodcastData();
}

// ---- News Briefs ----
const NB_CACHE_KEY = 'bigtech_nb_cache';
const NB_CACHE_TTL = 1800000; // 30 minutes
const NB_SEND_KEY = 'bigtech_nb_last_send';
const NB_AUTO_KEY = 'bigtech_nb_auto_email';
const NB_MANUAL_KEY = 'bigtech_nb_manual';
const NB_WORKER_URL = 'https://news-briefs-rewriter.alex-kantrowitz.workers.dev';
const NB_CORS_PROXIES = [
    url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
    url => `https://corsproxy.io/?${encodeURIComponent(url)}`
];
const NB_PREFERRED_SOURCES = [
    'the verge', 'techcrunch', 'wsj', 'wall street journal', 'new york times', 'nytimes',
    'wired', 'cnbc', 'bloomberg', 'ars technica', 'semafor', 'the information',
    'platformer', '404 media', 'reuters', 'associated press', 'washington post',
    'financial times', 'the atlantic', 'bbc', 'theverge'
];

let nbWeekOffset = 0; // 0 = current week, -1 = last week, etc.

function getNbWeekWindow(offset = 0) {
    // Rolling 7-day window ending today
    const now = new Date();
    const et = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));

    const end = new Date(et);
    end.setDate(end.getDate() + (offset * 7));
    end.setHours(23, 59, 59, 999);

    const start = new Date(end);
    start.setDate(start.getDate() - 6);
    start.setHours(0, 0, 0, 0);

    return { start, end };
}

function formatNbDate(d) {
    return d.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
}

function getNbCache() {
    try {
        const raw = localStorage.getItem(NB_CACHE_KEY);
        if (!raw) return null;
        const cache = JSON.parse(raw);
        if (Date.now() - cache.timestamp > NB_CACHE_TTL) return null;
        return cache;
    } catch (e) { return null; }
}

function setNbCache(stories) {
    localStorage.setItem(NB_CACHE_KEY, JSON.stringify({ timestamp: Date.now(), stories }));
}

async function fetchTechmemeRSS() {
    const feedUrl = 'https://techmeme.com/feed.xml';

    for (let i = 0; i < NB_CORS_PROXIES.length; i++) {
        try {
            const proxyUrl = NB_CORS_PROXIES[i](feedUrl);
            const res = await fetch(proxyUrl);
            if (!res.ok) continue;
            const text = await res.text();
            return parseRSSFeed(text);
        } catch (e) {
            console.warn(`[NB] Proxy ${i} failed:`, e.message);
        }
    }
    throw new Error('All CORS proxies failed. Try again later.');
}

function parseRSSFeed(xml) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(xml, 'text/xml');
    const items = doc.querySelectorAll('item');
    const stories = [];

    items.forEach(item => {
        const rawTitle = item.querySelector('title')?.textContent?.trim() || '';
        const link = item.querySelector('link')?.textContent?.trim() || '';
        const desc = item.querySelector('description')?.textContent?.trim() || '';
        const pubDate = item.querySelector('pubDate')?.textContent?.trim() || '';

        // Extract source from title ‚Äî Techmeme format: "Headline text (Author/Publication)"
        let source = '';
        let title = rawTitle;
        const titleSourceMatch = rawTitle.match(/\(([^)]+\/([^)]+))\)\s*$/);
        if (titleSourceMatch) {
            source = titleSourceMatch[2].trim();
            // Strip the attribution from the title
            title = rawTitle.replace(/\s*\([^)]*\/[^)]*\)\s*$/, '').trim();
        } else {
            // Some entries have just (Publication) without author
            const titlePubMatch = rawTitle.match(/\(([^)/]+)\)\s*$/);
            if (titlePubMatch) {
                source = titlePubMatch[1].trim();
                title = rawTitle.replace(/\s*\([^)]+\)\s*$/, '').trim();
            }
        }

        // Fallback: extract source from description HTML
        // Description format: "Author / <a href="...">Publication</a>:"
        if (!source) {
            const descDoc = parser.parseFromString(desc, 'text/html');
            const allLinks = descDoc.querySelectorAll('a');
            for (const a of allLinks) {
                const href = a.getAttribute('href') || '';
                const text = a.textContent.trim();
                // Skip techmeme links and image links ‚Äî look for publication name links
                if (!href.includes('techmeme.com') && text.length > 1 && text.length < 40 && !href.match(/\.(jpg|png|gif)$/i)) {
                    source = text;
                    break;
                }
            }
        }

        // Final fallback: extract from article link domain
        if (!source) {
            const descDoc = parser.parseFromString(desc, 'text/html');
            const allLinks = descDoc.querySelectorAll('a');
            for (const a of allLinks) {
                const href = a.getAttribute('href') || '';
                if (href && !href.includes('techmeme.com') && !href.match(/\.(jpg|png|gif)$/i)) {
                    try {
                        const url = new URL(href);
                        source = url.hostname.replace('www.', '').split('.')[0];
                        source = source.charAt(0).toUpperCase() + source.slice(1);
                    } catch (e) {}
                    break;
                }
            }
        }

        // Extract original article link from description if Techmeme link
        let articleLink = link;
        const descDoc2 = parser.parseFromString(desc, 'text/html');
        const allLinks2 = descDoc2.querySelectorAll('a');
        for (const a of allLinks2) {
            const href = a.getAttribute('href') || '';
            if (href && !href.includes('techmeme.com') && !href.match(/\.(jpg|png|gif)$/i)) {
                articleLink = href;
                break;
            }
        }

        if (title) {
            stories.push({
                title,
                link: articleLink,
                source: source || 'Techmeme',
                pubDate: pubDate ? new Date(pubDate) : new Date(),
                description: descDoc2.body?.textContent?.trim() || ''
            });
        }
    });

    return stories;
}

function rankNbStories(stories, window) {
    // Filter to the week window
    const filtered = stories.filter(s => {
        const d = s.pubDate;
        return d >= window.start && d <= window.end;
    });

    // Score: position bonus (earlier in RSS = more prominent) + preferred source boost
    filtered.forEach((s, i) => {
        let score = Math.max(0, 100 - i); // Position score (higher = earlier in feed)
        const srcLower = s.source.toLowerCase();
        if (NB_PREFERRED_SOURCES.some(p => srcLower.includes(p))) {
            score += 25; // Preferred source boost
        }
        s.score = score;
    });

    // Deduplicate by similar titles (keep highest scored)
    const seen = new Map();
    filtered.forEach(s => {
        const key = s.title.toLowerCase().replace(/[^a-z0-9]/g, '').substring(0, 40);
        if (!seen.has(key) || s.score > seen.get(key).score) {
            seen.set(key, s);
        }
    });

    const unique = [...seen.values()];
    unique.sort((a, b) => b.score - a.score);
    return unique.slice(0, 10);
}

async function rewriteNbHeadlines(stories) {
    if (!stories || stories.length === 0) return stories;
    try {
        const headlines = stories.map(s => s.title);
        const res = await fetch(NB_WORKER_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ headlines })
        });
        if (!res.ok) {
            console.warn('[NB] Rewrite worker error:', res.status);
            return stories;
        }
        const data = await res.json();
        if (data.rewritten && data.rewritten.length === stories.length) {
            stories.forEach((s, i) => {
                s.originalTitle = s.title;
                s.title = data.rewritten[i];
            });
        }
    } catch (e) {
        console.warn('[NB] Rewrite failed, using original headlines:', e.message);
    }
    return stories;
}

async function loadNewsBriefs() {
    const container = document.getElementById('nbContainer');

    // Try cache first (only for current week offset 0)
    if (nbWeekOffset === 0) {
        const cache = getNbCache();
        if (cache && cache.stories && cache.stories.length > 0) {
            nbRenderMerged(cache.stories);
            return;
        }
    }

    // Check for saved week data
    const savedKey = `bigtech_nb_week_${nbWeekOffset}`;
    try {
        const saved = localStorage.getItem(savedKey);
        if (saved) {
            const parsed = JSON.parse(saved);
            if (parsed.stories && parsed.stories.length > 0) {
                // Restore Date objects
                parsed.stories.forEach(s => s.pubDate = new Date(s.pubDate));
                nbRenderMerged(parsed.stories);
                return;
            }
        }
    } catch (e) {}

    container.innerHTML = '<div class="vp-loading"><div class="spinner"></div>Fetching stories from Techmeme...</div>';

    try {
        const allStories = await fetchTechmemeRSS();
        const window = getNbWeekWindow(nbWeekOffset);
        const top10 = rankNbStories(allStories, window);

        // Rewrite headlines with Claude via Worker
        if (top10.length > 0) {
            container.innerHTML = '<div class="vp-loading"><div class="spinner"></div>Rewriting headlines with AI...</div>';
            await rewriteNbHeadlines(top10);
        }

        // Cache results (with rewritten titles)
        if (nbWeekOffset === 0) {
            setNbCache(top10);
        }
        // Also save per-week
        localStorage.setItem(`bigtech_nb_week_${nbWeekOffset}`, JSON.stringify({ stories: top10 }));

        nbRenderMerged(top10);
    } catch (err) {
        console.error('[NB] Fetch error:', err);
        container.innerHTML = `<div class="vp-loading" style="color:var(--red);">Failed to load stories: ${err.message}</div>`;
    }
}

function nbRenderMerged(autoStories) {
    const manual = getNbManualLinks().map(m => ({ ...m, pubDate: new Date(m.pubDate) }));
    const combined = [...manual, ...autoStories];
    renderNewsBriefs(combined);
}

function renderNewsBriefs(stories) {
    const container = document.getElementById('nbContainer');
    const window = getNbWeekWindow(nbWeekOffset);
    const isCurrentWeek = nbWeekOffset === 0;
    const autoEmail = localStorage.getItem(NB_AUTO_KEY) === 'true';
    const lastSend = localStorage.getItem(NB_SEND_KEY);
    const lastSendText = lastSend ? `Last sent: ${new Date(parseInt(lastSend)).toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' })}` : 'Never sent';

    let html = `
        <div class="nb-header">
            <h2>üì∞ News Briefs</h2>
            <div class="nb-week-nav">
                <button class="nb-week-btn" onclick="nbChangeWeek(-1)">‚Äπ</button>
                <span class="nb-week-label">${formatNbDate(window.start)} ‚Üí ${formatNbDate(window.end)}</span>
                <button class="nb-week-btn" onclick="nbChangeWeek(1)" ${isCurrentWeek ? 'disabled' : ''}>‚Ä∫</button>
            </div>
        </div>
        <div class="nb-add-link">
            <span style="font-size:18px;">üîó</span>
            <input type="text" id="nbLinkInput" placeholder="Paste a link to add it to the briefs..." onkeydown="if(event.key==='Enter')nbAddLink()">
            <button class="btn btn-primary" onclick="nbAddLink()" id="nbAddBtn">+ Add</button>
        </div>
        <div class="nb-actions">
            <button class="btn btn-primary" onclick="nbRefresh()">üîÑ Refresh</button>
            <button class="btn btn-accent" onclick="nbCopyForNewsletter()" ${stories.length === 0 ? 'disabled' : ''}>üìã Copy for Newsletter</button>
            <button class="btn btn-email" onclick="nbSendEmail()" ${stories.length === 0 ? 'disabled' : ''}>üìß Send Email Now</button>
            <span class="nb-status" id="nbStatus"></span>
        </div>
    `;

    if (stories.length === 0) {
        html += '<div class="nb-empty">No stories found for this week yet. Stories accumulate Saturday through Thursday.</div>';
    } else {
        html += '<div class="nb-list">';
        stories.forEach((s, i) => {
            const dateStr = s.pubDate ? new Date(s.pubDate).toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }) : '';
            const addedBadge = s.manual ? '<span class="nb-added-tag">added</span>' : '';
            const removeBtn = s.manual ? ` <span style="cursor:pointer;color:var(--silver);font-size:12px;margin-left:6px;" onclick="nbRemoveManual(${i})" title="Remove">‚úï</span>` : '';
            html += `
                <div class="nb-item">
                    <div class="nb-rank">${i + 1}</div>
                    <div class="nb-content">
                        <div class="nb-headline" ${s.originalTitle ? `title="${esc(s.originalTitle)}"` : ''}>${esc(s.title)}${addedBadge}${removeBtn}</div>
                        <span class="nb-source">[<a href="${esc(s.link)}" target="_blank" rel="noopener">${esc(s.source)}</a>]</span>
                        <span class="nb-date">${dateStr}</span>
                    </div>
                </div>`;
        });
        html += '</div>';
    }

    // Auto-email row
    html += `
        <div class="nb-email-row">
            <label>Auto-email Thursday 6 PM ET</label>
            <label class="nb-toggle">
                <input type="checkbox" ${autoEmail ? 'checked' : ''} onchange="nbToggleAutoEmail(this.checked)">
                <span class="nb-toggle-slider"></span>
            </label>
            <span class="nb-email-status">${lastSendText}</span>
        </div>
    `;

    container.innerHTML = html;
}

function nbChangeWeek(dir) {
    nbWeekOffset += dir;
    if (nbWeekOffset > 0) nbWeekOffset = 0;
    loadNewsBriefs();
}

function nbRefresh() {
    // Clear cache for current week and re-fetch
    localStorage.removeItem(NB_CACHE_KEY);
    localStorage.removeItem(`bigtech_nb_week_${nbWeekOffset}`);
    loadNewsBriefs();
}

function nbCopyForNewsletter() {
    const savedKey = nbWeekOffset === 0 ? NB_CACHE_KEY : `bigtech_nb_week_${nbWeekOffset}`;
    let autoStories = [];

    try {
        const raw = localStorage.getItem(savedKey);
        if (raw) {
            const parsed = JSON.parse(raw);
            autoStories = parsed.stories || parsed;
        }
    } catch (e) {}

    // Also check direct cache
    if (autoStories.length === 0) {
        try {
            const raw = localStorage.getItem(NB_CACHE_KEY);
            if (raw) autoStories = JSON.parse(raw).stories || [];
        } catch (e) {}
    }

    // Merge manual links at top
    const manual = getNbManualLinks();
    const stories = [...manual, ...autoStories];

    if (stories.length === 0) {
        toast('No stories to copy', 'error');
        return;
    }

    // Format as "What Else I'm Reading" style (use rewritten title, fallback to original)
    const lines = stories.map(s => {
        const headline = s.title || s.originalTitle || 'Untitled';
        return `**${headline}** [${s.source}](${s.link})`;
    });

    const text = lines.join('\n\n');
    navigator.clipboard.writeText(text).then(() => {
        const el = document.getElementById('nbStatus');
        if (el) { el.textContent = 'Copied!'; el.className = 'nb-status success'; }
        toast('Stories copied to clipboard!', 'success');
        setTimeout(() => { if (el) { el.textContent = ''; el.className = 'nb-status'; } }, 3000);
    }).catch(() => {
        // Fallback
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        toast('Stories copied to clipboard!', 'success');
    });
}

function nbToggleAutoEmail(enabled) {
    localStorage.setItem(NB_AUTO_KEY, enabled ? 'true' : 'false');
    toast(enabled ? 'Auto-email enabled for Thursday 6 PM ET' : 'Auto-email disabled', 'success');
}

function nbGetStoriesForEmail() {
    // Get current week auto stories
    let autoStories = [];
    const cache = getNbCache();
    if (cache && cache.stories && cache.stories.length > 0) {
        autoStories = cache.stories;
    } else {
        const saved = localStorage.getItem('bigtech_nb_week_0');
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                if (parsed.stories && parsed.stories.length > 0) autoStories = parsed.stories;
            } catch (e) {}
        }
    }
    // Merge manual links at top
    const manual = getNbManualLinks();
    return [...manual, ...autoStories];
}

function nbBuildEmailHtml(stories) {
    const window = getNbWeekWindow(0);
    let html = `<h2 style="font-family:Inter,sans-serif;color:#1a2332;">üì∞ News Briefs</h2>`;
    html += `<p style="font-family:Inter,sans-serif;color:#8899aa;font-size:13px;">${formatNbDate(window.start)} ‚Üí ${formatNbDate(window.end)}</p>`;
    html += `<div style="font-family:Inter,sans-serif;">`;

    stories.forEach((s, i) => {
        html += `<p style="margin:12px 0;font-size:14px;line-height:1.5;">
            <strong>${i + 1}. ${s.title}</strong>
            <span style="color:#8899aa;font-size:12px;">[<a href="${s.link}" style="color:#4a90d9;">${s.source}</a>]</span>
        </p>`;
    });

    html += `</div>`;
    return html;
}

async function nbSendEmail() {
    const stories = nbGetStoriesForEmail();
    if (stories.length === 0) {
        toast('No stories to send', 'error');
        return;
    }

    const settings = loadSettings();
    if (!settings.emails || settings.emails.length === 0) {
        toast('No email recipients configured. Check Email Settings tab.', 'error');
        return;
    }

    const window = getNbWeekWindow(0);
    const subject = `News Briefs: ${formatNbDate(window.start)} ‚Üí ${formatNbDate(window.end)}`;
    const body = nbBuildEmailHtml(stories);

    try {
        // Use the same EmailJS setup as the main tracker
        const serviceId = settings.serviceId || 'default_service';
        const templateId = settings.templateId;
        const publicKey = settings.publicKey;

        if (!templateId || !publicKey) {
            toast('EmailJS not configured. Check Email Settings.', 'error');
            return;
        }

        await emailjs.send(serviceId, templateId, {
            to_email: settings.emails.join(','),
            subject: subject,
            message: body
        }, publicKey);

        localStorage.setItem(NB_SEND_KEY, Date.now().toString());
        toast('News briefs email sent!', 'success');

        // Re-render to update "Last sent" text
        const cachedStories = nbGetStoriesForEmail();
        if (cachedStories.length > 0) renderNewsBriefs(cachedStories);
    } catch (err) {
        console.error('[NB] Email error:', err);
        toast('Email failed: ' + (err.text || err.message || 'Unknown error'), 'error');
    }
}

// Auto-email check: runs every 15 minutes
setInterval(() => {
    const autoEnabled = localStorage.getItem(NB_AUTO_KEY) === 'true';
    if (!autoEnabled) return;

    const now = new Date();
    const et = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
    const day = et.getDay(); // 4 = Thursday
    const hour = et.getHours();
    const min = et.getMinutes();

    // Thursday between 6:00 PM and 6:15 PM ET
    if (day === 4 && hour === 18 && min < 15) {
        const lastSend = parseInt(localStorage.getItem(NB_SEND_KEY) || '0');
        const hoursSinceSend = (Date.now() - lastSend) / 3600000;

        if (hoursSinceSend > 24) {
            console.log('[NB] Auto-sending Thursday evening email...');
            nbSendEmail();
        }
    }
}, 900000); // Every 15 minutes

// ---- News Briefs: Manual Link Add ----
function getNbManualLinks() {
    try {
        const raw = localStorage.getItem(NB_MANUAL_KEY);
        return raw ? JSON.parse(raw) : [];
    } catch (e) { return []; }
}

function saveNbManualLinks(links) {
    localStorage.setItem(NB_MANUAL_KEY, JSON.stringify(links));
}

async function nbAddLink() {
    const input = document.getElementById('nbLinkInput');
    const btn = document.getElementById('nbAddBtn');
    let url = input.value.trim();
    if (!url) return;

    // Auto-add https:// if missing
    if (!url.match(/^https?:\/\//i)) url = 'https://' + url;

    btn.textContent = '‚è≥';
    btn.disabled = true;

    try {
        const resp = await fetch(NB_WORKER_URL + '/fetch-link?url=' + encodeURIComponent(url));
        const data = await resp.json();

        if (data.error) {
            toast('Failed to fetch link: ' + data.error, 'error');
            return;
        }

        const originalTitle = data.title || url;

        // Rewrite headline in our style via Claude
        let rewrittenTitle = originalTitle;
        try {
            btn.textContent = '‚úçÔ∏è';
            const rwResp = await fetch(NB_WORKER_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ headlines: [originalTitle] })
            });
            const rwData = await rwResp.json();
            if (rwData.rewritten && rwData.rewritten[0]) {
                rewrittenTitle = rwData.rewritten[0];
            }
        } catch (e) {
            console.warn('[NB] Rewrite failed, using original title:', e.message);
        }

        const story = {
            title: rewrittenTitle,
            originalTitle: originalTitle,
            link: data.link || url,
            source: data.source || new URL(url).hostname.replace('www.', ''),
            pubDate: new Date().toISOString(),
            manual: true,
        };

        // Save to manual links store
        const manual = getNbManualLinks();
        // Dedupe by link
        const exists = manual.some(m => m.link === story.link);
        if (!exists) {
            manual.unshift(story);
            saveNbManualLinks(manual);
        }

        input.value = '';
        toast('Link added!', 'success');

        // Re-render with the manual links merged in
        nbRenderWithManual();
    } catch (err) {
        toast('Error: ' + err.message, 'error');
    } finally {
        btn.textContent = '+ Add';
        btn.disabled = false;
    }
}

function nbRemoveManual(indexInCombined) {
    // Get current combined list to find which manual link to remove
    const cache = nbGetCurrentStories();
    const manual = getNbManualLinks();
    const combined = [...manual, ...cache];
    const story = combined[indexInCombined];
    if (story && story.manual) {
        const idx = manual.findIndex(m => m.link === story.link);
        if (idx >= 0) {
            manual.splice(idx, 1);
            saveNbManualLinks(manual);
            nbRenderWithManual();
        }
    }
}

function nbGetCurrentStories() {
    // Get the auto-fetched stories for the current week
    if (nbWeekOffset === 0) {
        const cache = getNbCache();
        if (cache && cache.stories) return cache.stories;
    }
    try {
        const saved = localStorage.getItem(`bigtech_nb_week_${nbWeekOffset}`);
        if (saved) {
            const parsed = JSON.parse(saved);
            if (parsed.stories) {
                parsed.stories.forEach(s => s.pubDate = new Date(s.pubDate));
                return parsed.stories;
            }
        }
    } catch (e) {}
    return [];
}

function nbRenderWithManual() {
    const autoStories = nbGetCurrentStories();
    nbRenderMerged(autoStories);
}

// ---- Copy Shareable Link ----
// ---- Toast ----
function toast(msg, type = '') {
    const el = document.getElementById('toast');
    el.textContent = msg;
    el.className = 'toast show ' + type;
    setTimeout(() => el.className = 'toast', 3000);
}

// ---- Column Resize ----
const COL_WIDTHS_KEY = 'bigtech_col_widths';
const DEFAULT_COL_WIDTHS = [44, 140, 110, 100, 80, 140, 110, 80, 140, 75, 75, 70, 110, 130, 140, 130, 52];

function initColumnResize() {
    const ths = document.querySelectorAll('table thead th');
    if (!ths.length) return;

    // Restore saved widths or use defaults
    let saved = null;
    try { saved = JSON.parse(localStorage.getItem(COL_WIDTHS_KEY)); } catch(e) {}
    const widths = saved && saved.length === ths.length ? saved : [...DEFAULT_COL_WIDTHS];

    ths.forEach((th, i) => {
        th.style.width = widths[i] + 'px';
        th.style.position = 'sticky'; // keep sticky

        // Remove old handles if re-initializing
        const old = th.querySelector('.col-resize-handle');
        if (old) old.remove();

        // Don't add handle to last column
        if (i === ths.length - 1) return;

        const handle = document.createElement('div');
        handle.className = 'col-resize-handle';
        th.style.position = 'sticky';
        th.appendChild(handle);

        handle.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const startX = e.pageX;
            const startW = th.offsetWidth;
            handle.classList.add('active');
            document.body.classList.add('col-resizing');

            function onMove(e2) {
                const w = Math.max(40, startW + (e2.pageX - startX));
                th.style.width = w + 'px';
            }
            function onUp() {
                handle.classList.remove('active');
                document.body.classList.remove('col-resizing');
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
                // Save all widths
                const allW = Array.from(ths).map(t => t.offsetWidth);
                localStorage.setItem(COL_WIDTHS_KEY, JSON.stringify(allW));
            }
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        });
    });
}

// ---- Init ----
loadActiveVideos();
renderMonthBar();
renderTable();
updateStats();
updateSubtitle();
renderSettings();

// ---- Strip legacy #config= hash if present ----
if (window.location.hash && window.location.hash.startsWith('#config=')) {
    history.replaceState(null, '', window.location.pathname + window.location.search);
}

// ---- Sync from cloud on load ----
(async function syncOnLoad() {
    // 1) Sync settings from Worker KV (source of truth for email settings)
    const workerSettings = await fetchSettingsFromWorker();
    if (workerSettings && workerSettings.emails && workerSettings.emails.length > 0) {
        console.log('[Settings] Loaded from Worker KV:', workerSettings.emails.length, 'email(s)');
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(workerSettings));
        renderSettings();
    }

    // 2) Sync months data from npoint cloud
    if (!cloudSyncEnabled) return;
    console.log('[SYNC] Starting sync from', NPOINT_URL);
    const cloudData = await fetchFromCloud();
    const localData = loadMonthsData();

    const cloudVideos = cloudData?.months?.reduce((s, m) => s + (m.videos?.length || 0), 0) || 0;
    const localVideos = localData.months.reduce((s, m) => s + m.videos.length, 0);
    console.log('[SYNC] Cloud:', cloudData?.months?.length || 0, 'months,', cloudVideos, 'videos | Local:', localData.months.length, 'months,', localVideos, 'videos');

    if (cloudData && cloudData.months && cloudData.months.length > 0 && cloudVideos > 0) {
        // Cloud has real data ‚Äî use it as source of truth on page load
        console.log('[SYNC] Using cloud data as source of truth');
        localStorage.setItem(MONTHS_KEY, JSON.stringify(cloudData));
        loadActiveVideos();
        renderMonthBar();
        renderTable();
        updateStats();
        updateSubtitle();
        toast('Synced from cloud (' + cloudVideos + ' videos)', 'success');
    } else {
        // Cloud is empty or unreachable ‚Äî seed it from local
        console.log('[SYNC] Cloud empty ‚Üí seeding from local (' + localVideos + ' videos)');
        if (localVideos > 0) {
            localData.settings = loadSettings();
            localData.lastModified = Date.now();
            await saveToCloud(localData);
            toast('Local data pushed to cloud (' + localVideos + ' videos)', 'success');
        }
    }
})();
</script>
</body>
</html>
